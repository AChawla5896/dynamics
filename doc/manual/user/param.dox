/*! \page user_param_page 2.3 Parameter File

All of the Simpatico programs use parameter files with a heirarchical file format. Each parameter file contains a set of nested blocks that begin and end with matched curly brackets, like blocks in a C program.  The parameter files required by the three programs mcSim, mdSim and ddSim use a similar syntax, but differ in many details. 

\section param_example_section Example: mdSim parameter file 
As an example, here is a complete parameter file for a simple constant energy (NVE) MD simulation, for use with the default version of mdSim. Other example parameter files for mdSim, mcSim and ddSim can be found in the simpatico/examples/ directory. 

\code
MdSimulation{
  FileMaster{
    commandFileName               commands
    inputPrefix                        in/
    outputPrefix                      out/
  }
  nAtomType                              2
  nBondType                              1
  atomTypes                              A   1.000
                                         B   1.000
  maskedPairPolicy              MaskBonded
  SpeciesManager{

    Homopolymer{
      moleculeCapacity                     100
      nAtom                                  8
      atomType                               0
      bondType                               0
    }

    Homopolymer{
      moleculeCapacity                     100
      nAtom                                  8
      atomType                               1
      bondType                               0
    }

  }
  Random{
    seed                           10742892
  }
  MdSystem{
    pairStyle                        LJPair
    bondStyle                  HarmonicBond 
    MdPairPotential{
      epsilon               1.000000000000e+00  1.500000000000e+00
                            1.500000000000e+00  1.000000000000e+00
      sigma                 1.000000000000e+00  1.000000000000e+00
                            1.000000000000e+00  1.000000000000e+00
      cutoff                1.122460000000e+00  1.122460000000e+00
                            1.122460000000e+00  1.122460000000e+00
      maxBoundary           cubic       12.000   
      PairList{
        atomCapacity                        1000
        pairCapacity                       10000
        skin                  2.500000000000e-01
      }
    }
    BondPotential{
      kappa                 4.000000000000e+02
      length                1.000000000000e+00
    }
    EnergyEnsemble{
      type                        adiabatic
    }
    BoundaryEnsemble{
      type                            rigid
    }
    NveVvIntegrator{
       dt                   5.000000000000e-03
    }
  }
  DiagnosticManager{
    baseInterval                          10

    LogProgress{
      interval                          1000
    }

    DumpConfig{
      interval                          1000
      outputFileName                   dump/
    }

    MdEnergyOutput{
      interval                          1000
      outputFileName                  energy
    }

  }
  writeRestartInterval             10000
  writeRestartFileName           restart
}
\endcode

\section param_format_section Parameter File Syntax

Before discussing the contents of this and other examples, consider the syntax of a parameter file, using the above as an example. All Simpatico parameter files contain a set of nested blocks. Each block is delimited by lines containing opening and closing curly brackets, much like the structure of a C program. Each block may nested subblocks, as well as lines that give values for individual simulation parameters.  Each sub-block and each parameter value is preceded by a label string. 

The order of appearance of elements within each block is generally fixed (i.e., hard-coded) by the implementation of the function that reads that block. If the expected label for a parameter or block is not found at the expected position in a parameter file, the program will output a message indicating the nature of the error (i.e., what label was expected and what label was actually read), and then halt execution. These error messages are easier to interpret if one uses "-e" command line option for each of the main programs. This option causes each block and parameter in the parameter file to be echoed to standard output immediately after it is read, thus allowing one to see exactly where in the file an error was encountered.

\subsection param_block_subsection Parameter Blocks
The nesting of parameter blocks in this file format reflects the hierarchical organization of C++ objects that is used in the underlying program design: Each block in the parameter file corresponds to a specific C++ object. Throughout the Simpatico source code, objects are organized into a hierarchy in which each object can have any number of "child" objects.  A child object is generally either a member variable of its parent or a dynamically allocated object that the parent is responsible for creating and destroying. Every object except the root object has exactly one "parent". Every object in this hierarchy is responsible for reading a block in the parameter file that contains all the parameters necessary to initialize the state of that object. As part of this, the function that reads such a block must invoke corresponding functions to read parameter blocks associated with its children.  The root node of this herarchy is the main simulation object, which is always an instance of McMd::McSimulation (for mcSim simulations), McMd::MdSimulation (for mdSim) or DdMd::Simulation (for ddSim).

Each parameter file block begins with a line containing a label, following by an opening brace ("{"). The label is the name of the class of the associated C++ object. No white space may appear between the class name and the opening brace.  For example, the block that initializes the "MdSystem" object in the above example begins with the line "MdSystem{".  Each block ends with a line containing only a matched closing brace (i.e., "}").  By convention, nested blocks are indented, but indentation and additional white space are actually ignored when the file is parsed.  

\subsection param_subsection Individual Parameters 
Parameter blocks may also contain values of individual parameters, in addition to nested subblocks.  The value of each parameter that is represented by a primitive C++ variable (e.g., an int, double, or bool) or by a std::string is given on a single line that contains a string label followed by the parameter value. Parameter labels must be single words, with no white space. Each parameter is stored in a member variable of the class named in the first line of the innermost enclosing parameter block. By convention, the label that precedes the value of each parameter is a slightly modified version of the name of the associated class member variable. Throughout Simpatico, the names of private class members end with an underscore. The name of the associated parameter value is given by the member variable name without the trailing underscore. For example, the number of atom types in an MdSimulation is given by private member variable named nAtomType_, whose value is indicated in the parameter file by a label "nAtomType". 

Some parameters give values for variables that are instances of non-primitive data types, such as enumerations or small classes.  The value of each such parameter is also given on a single line containing a label followed by a text representation of its value.  The text representation of the "value" of each such non-primitive variable must be defined by iostream extractor (>>) and insertor (<<) operators that are defined for that data type.  For example, in the above file, the "type" member of the EnergyEnsemble object is an instance of the enumeration EnergyEnsemble::Type. This enum can have values ADIABATIC (constant energy) or ISOTHERMAL (constant temperature).  The value of this variable is read by an overloaded extractor (>>) operator that recognizes either lower case "adiabatic" or upper case "ADIABATIC" as valid string representations of the ADIABATIC enum value.

Some parameters are also stored internally in one-dimensional (1D) arrays. A 1D array of parameters is represented in a parameter file by a sequence of lines in which the first line contains the label (the name of the array) and the value of the first element, while subsequent lines contain values of subsequent elements.  For example, the atomTypes member of an MdSimulation is an array that contains nAtomType instances of class AtomType. The string representation of an AtomType, which is defined by an extractor (>>) operator that takes an AtomType argument, contains a name string ("A" or "B" in this example) followed by a floating point value for the mass. (The mass is 1.0 for both types in the example). The number of elements in such an array must be known before the array is read, and is passed as a parameter to the function that reads an array of parameters. In this case, the number of elements in the atomTypes array is given by the value of "nAtomType", which appears before the "atomTypes" array in the file format. In the example, because nAtomType = 2, the atomTypes array contains two lines.

Variables that are stored internally in two-dimensional arrays or Util::Matrix objects also use a multi-line parameter file format. In this case, the first line contains a label (the name of the associated 2D array or Util::Matrix variable), followed by the elements of the first row, with subsequent rows on subsequent lines. In the above example, this format is used for the epsilon, sigma, and cutoff members of an LJPair pair potential object, which are each 2 x 2 matrices in this example. In LJPair, of these parameters is stored internally as a two dimensional C-array, in which epsilon[i][j] is the value of the Lennard-Jones epsilon parameter for interactions between atoms of types i and j, for 0 < i, j <= nAtomType.

The meaning of most parameter labels should be self-explanatory. When they are not, the conventions used in this file format are designed to make it easy for users to look up the meaning of the variable in the html documentation or source code: Each parameter in this file format is labelled by the name of an associated member variable of a class. The relevant class is given by the class name in the first line of the intermost enclosing block. The meaning of every member variable is almost always adequately explained in the html doxygen class documentation of the class, and is always documented in the header (*.h) file of the enclosing class.

\subsection polymorphic_section Polymorphic Blocks

Some blocks in a Simpatico parameter file are "polymorphic". A polymorphic parameter file block may contain teh file format appropriate to any of several possible subclasses of a particular base class. The use of polymorphic blocks is the main mechanism used in simpatico to allow a user to use a text file to choose which elements of a simulation (e.g., which integration algorithms, diagnostics, and file formats) should be used in a particular simulation. 

 
One polymorphic block in the above example is the block associated with the molecular dynamics integrator (McMd::MdIntegrator) of an McMd::MdSystem. This appears at the end of the MdSystem block, and begins with a line labelled "NveVvIntegrator{", which is the name of a subclass of McMd::MdIntegrator.. In an mdSim molecular dynamics simulation, the McMd::MdSystem object has one associated McMd::MdIntegrator object. The user may specify that this object should an instance of any of several subclasses of MdIntegrator. Among these are McMd::NveVvIntegrator, which implements an energy conserving NVE velocity-Verlet integrator, or McMd::NvtNhIntegrator, which implements an isothermal NVT Nose-Hoover integrator. If an McMd::NveVvIntegrator block is encountered at the place expected for a polymorphic MdIntegrator block (as in the above example) the parent McMd::MdSystem will create and initialize an McMd::NveVvIntegrator object.  To indicate that an McMd::NvtNhIntegrator was desired instead, this block in the parameter file could be changed to contain the file format for an McMd::NvtNhIntegrator, which would begin with the line "NvtNhIntegrator{". Different file formats and parameters are used for different subclasses: For example, the format for an NvtNhIntegrator contains a parameter that controls the strength of the coupling of the system to an additional variable, which is not needed in an NveVvIntegrator.

To read a polymorphic block, the method of the parent object that parses its parameter file block must: (1) read the first line of the sublock, and extract the name of the desired subclass, (2) compare the subclass name to a list of known subclasses, (3) create an instance of the desired subclass, which is assigned to a base class pointer, or throw an Exception if the class name is not recognized, and (4) call the readParameters method of the new object to read the body of the polymorphic parameter file block. The implementation of this algorithm relies on an associated "Factory" class that is responsible steps (2) and (3) of this process. Factory classes are discussed in more detail \ref extend_factory_page "here".

\subsection manager_subsection Manager Classes

The above example file contains two blocks labelled "SpeciesManager" and "DiagnosticManager" that are examples of Manager classes.  The parameter block associated with a Manager class contains a sequence of polymorphic subblocks, separated by spaces. Each subblock may contain the file format for any known subclass of the associated base class (e.g., any subclass of McMd::Species or McMd::Diagnostic). A Manager block may contain any number of such blocks, followed by a closing bracket on a line by itself. Thus for example, the sub-blocks of the SpeciesManager block lists all of the molecular species that may be present in the simulation. Each such sublock describes the chemical structure of a different species of molecules. The subblocks of the DiagnosticManager block instead list the subclasses of McMd::Diagnostic that should be used for data analysis and/or data output during a simulation. 

A Manager class is a container that holds an array of pointers to dynamically allocated objects that are all instances of (generally) different subclasses of a common base class. Thus, for example, an McMd::SpeciesManager has an array  of Species* pointers to McMd::Species objects (i.e., instances of any subclass of McMd::Species) that represent different types of molecule (or molecular species) within a mixture. An McMd::DiagnosticManager contains an array of McMd::Diagnostic* pointers to instances of subclasses of McMd::Diagnostics for data analysis and/or data output during a simulation. The parameter block for each such diagnostic object contains an integer "interval" parameter that specifies how often the analysis or output operation implemented by that object should be invoked. An mcSim Monte Carlo (MC) simulation also has an McMd::McMoveManager that contains an array of pointers to McMd::McMove objects that implement different Markov MC moves.

\subsection potential_section Potential Energies

In mcSim and mdSim simulations, the McMd::McSystem or McMd::MdSystem object has several associated types of potential energy. In a ddSim simulation, corresponding potential energies are members of the main DdMd::Simulation object. By default, in all three programs, these include only a non-bonded pair potential and a bond potential. Other types of potential energy, such as 3-body bond angle and 4-body dihedral potentials, may be enabled by defining associated macros (e.g., INTER_ANGLE and INTER_DIHEDRAL) in the file inter/defines.mk and recompiling. 

At run time, the user may choose from among several functional forms for each type of potential energy by specifying a "style" parameter string.  For example, the type of nonbonded pair potential function is specified by the value of the string "pairStyle". This can take on values such as "LJPair", corresponding to a Lennard-Jones potential, or "DpdPair", corresponding to the soft potential typically used in dissipative particle dynamics (DPD) simulations. Each of the allowed values of this pair style string corresponds to the name of class defined in the src/inter/pair directory. Similarly, "bondStyle" can take on values such as "HarmonicBond" or "FeneBond", which are the names of classes defined in the directory src/inter/bond. The classes that represent particular potential energy functions are referred to in what follows as "interaction" classes, and are all defined within the "Inter" namespace. 

In the above example, the "pairStyle" and "bondStyle" parameters appear near the top of the MdSystem block. The parameter file format for a code compiled with angle and dihedral potentials enabled would also contain "angleStyle" and "dihedralStyle" strings to specify choices of angle and dihedral interaction classes. These "style" variables are followed by a set of blocks that contain the parameters for different types of potential energy (pair, bond, etc.). In the above example, these blocks are labelled "MdPairPotential" and "BondPotential". Each of these blocks contains the set of parameters required by the potential energy function specified by the corresponding "style" variable.

The block associated with a pair potential contain information required to construct the cell list and/or pair list data structures that are used to evaluate pair interactions, in addition to actual interaction parameters. Because different data structures are used in MC and MD simulations, two different classes named McPairPotential and MdPairPotential are used to implement pair potentials in mcSim and mdSim simulations, respectively. In the above example parameter file for an mdSim simulation, the MdPairPotential block contains not only the parameters required by the associated interaction (the epsilon, sigma, and cutoff for the LJPair Lennard-Jones style), but also a parameter labelled maxBoundary and a PairList sub-block. These additional parameters are required to create a Verlet pairlist, which is needed to efficiently compute pair interactions in an MD simulation. The corresponding classes McPairPotential contains parameters that are required to create a cell list, but does not contain a PairList subblock. 

For covalent bonded interactions, the same potential class is used in mcSim and mdSim simulations. The class name for the object that represents a bond potential is thus simply called BondPotential, rather than MdBondPotential or McBondPotential.  The file format for a code compiled with angle and dihedral potentials would contains subsequent AnglePotential and DihedralPotential blocks. 

\subsection parsing_subsection How a parameter file is parsed

To use this file format effectively, and diagnose errors, it is useful to understand how it is parsed. As already noted, each block in a parameter file is associated with an object that is an instance of a class that is identified in the file format.  Each such class must be a subclass of the base class Util::ParamComposite. Each such class (with a few exceptions) redefines the virtual method Util::Paramcomposite::readParameters(std::istream&). This function must read the body of the associated parameter file block. The implementation of the readParameters() method defines the order in which individual parameters and nested sub-blocks must appear in the associated parameter file block. 

The most reliable documentation of the file format for each parameter block is thus provided by the source code of the the readParameters() method of the associated class. When an examination of available html documentation and error messages does not suffice to explain the required format, users can resort to reading the source code of this method. An explanation of the programming conventions used in all readParameters() methods is given \ref developer_param_page "here".  

\section param_McMd_section Parameter Files for mcSim and mdSim Simulations
We now discuss the parameter file formats for mcSim and mdSim in greater detail. Because these are similar in
most respects, we discuss them together.  An example of a parameter file for an
mdSim molecular dynamics simulation is shown above. Here is a corresponding example 
for an mcSim Monte Carlo simulation:
\code
McSimulation{
  FileMaster{
    commandFileName                 commands
    inputPrefix                          in/
    outputPrefix                        out/
  }
  nAtomType                                2
  nBondType                                1
  atomTypes                      A       1.0
                                 B       1.0
  maskedPairPolicy                MaskBonded
  SpeciesManager{

    Homopolymer{
      moleculeCapacity                      50
      nAtom                                  8
      atomType                               0
      bondType                               0
    }

    Homopolymer{
      moleculeCapacity                      50
      nAtom                                  8
      atomType                               1
      bondType                               0
    }
  }
  Random{
    seed                           13451892
  }
  McSystem{
    pairStyle                        LJPair
    bondStyle                  HarmonicBond
    McPairPotential{
      epsilon               1.000000000000e+00  1.300000000000e+00
                            1.300000000000e+00  1.000000000000e+00
      sigma                 1.000000000000e+00  1.000000000000e+00
                            1.000000000000e+00  1.000000000000e+00
      cutoff                1.122460000000e+00  1.122460000000e+00
                            1.122460000000e+00  1.122460000000e+00
      maxBoundary                 cubic  10.5 
    }
    BondPotential{
      kappa                 2.000000000000e+03
      length                1.000000000000e+00
    }
    EnergyEnsemble{
      type                  isothermal
      temperature           1.000000000000e+00
    }
    BoundaryEnsemble{
      type                  rigid
    }
  }
  McMoveManager{

    HybridMdMove{
      probability           0.002000000000e+00
      nStep                                 20
      MdSystem{
        MdPairPotential{
          maxBoundary                 cubic  10.5 
          PairList{
            atomCapacity                        1000
            pairCapacity                       10000
            skin                  3.000000000000e-01
          }
        }
        NveVvIntegrator{
          dt                    5.000000000000e-03
        }
      }
    }

    AtomDisplaceMove{
      probability           0.479000000000e+00
      speciesId                              0
      delta                               0.05
    }

    AtomDisplaceMove{
      probability           0.479000000000e+00
      speciesId                              1
      delta                               0.05
    }

    CfbReptationMove{
      probability           0.020000000000e+00
      speciesId                              0
      nTrial                                20
      hasAutoCorr                            0
    }

    CfbReptationMove{
      probability           0.020000000000e+00
      speciesId                              1
      nTrial                                20
      hasAutoCorr                            0
    }

  }
  DiagnosticManager{
    baseInterval                        1000

    LogProgress{
      interval                         10000
    }

    DumpConfig{
      interval                         1000
      outputFileName            dump/config.
    }

    McEnergyOutput{
      interval                          1000
      outputFileName                  energy
    }

    RadiusGyration{
      interval                          1000
      outputFileName          RadiusGyration
      nSamplePerBlock                     10
      speciesId                            0
    }

  }
  writeRestartInterval             10000
  writeRestartFileName           restart
}

\endcode
The formats for mcSim and mdSim are similar in most respects. The most important differences are:

  - The main block of mcSim simulation (which starts in the first line) is an McSimulation block, while the main block for an mdSim simulation is an MdSimulation block.

  - For mcSim, the main McSimulation block contains an McSystem subblock, whereas for mdSim, the main MdSimulation block contains an MdSystem subblock.

  - For mdSim, the MdSystem block contains a polymorphic subblock associated with the molecular dynamics integrator, which must be a subclass of McMd::MdIntegrator. There is no analogous subblock in the MdSystem block of an mcSim param file. 

  - For mcSim, the McSimulation block contains a McMoveManager subblock that contains polymorphic subblocks associated with different Monte Carlo moves (subclasses of McMd::McMoves). There is no analogous block in an mcSim param file. 

In outline, structure for an mdSimulation block for the default version of the code (without angle, dihedral or external potentials) is
\code
MdSimulation{
  FileMaster{
    ...
  }
  nAtomType    [int]
  nBondType    [int]
  atomTypes    [string (name)]   [float (mass)]
               ...
  maskedPairPolicy   [string]
  SpeciesManager{
     ...
  }
  Random{
    seed       [int]
  }
  MdSystem{
     ...
  }
  writeRestartInterval    [int]
  writeRestartFileName    [string]
\endcode
The corresponding default format for an McSimulation is:
\code
McSimulation{
  FileMaster{
    ...
  }
  nAtomType    [int]
  nBondType    [int]
  atomTypes    [string (name)]   [float (mass)]
               ...
  maskedPairPolicy   [string]
  SpeciesManager{
     ...
  }
  Random{
    seed       [int]
  }
  McSystem{
    ...
  }
  McMoveManager{
    ...
  }
  DiagnosticManager{
    ...
  }
  writeRestartInterval  [int]
  writeRestartFileName  [string]
\endcode

The following parameters appear in the main (Mc|Md)Simulation block in both types of simulation:
<ul>
<li> nAtomType: The number of atom types, which are indexed by an integer index with values 0, ...,  nAtomType - 1. </li>
<li> nAtomType: The number of bond types, which are indexed by an integer index with values 0, ...,  nBondType - 1. </li>
<li> atomTypes: atomTypes is an array of values of type McMd::AtomType. The string representation of each atom type consists of a string label (e.g., "A" or "B") followed by a floating point mass. </li>
<li> writeRestartInterval: The interval, in MD time steps or attempted MC moves, between time steps when a restart file is written.
<li> writeRestartFileName: The base name used for the restart file.
</ul>
The writeRestartInterval and writeRestartFileName parameters are discussed in more detail \ref user_restart_page "here".

\subsection user_param_filemaster_subsection FileMaster
The FileMaster block is associated with an instance of Util::FileMaster. This block contains several string parameters that specify locations of input and output files. The parameter "commandFileName" is the name of the command file that will control program execution. The "inputPrefix" string is prepended to the names of input configuration files and other input files. The "outputPrefix" string is predended to the names of various output files. Input and output files can be placed in separate directories by giving values for these two prefixes that are directory names, in which case the strings should end with a backslash. 

\subsection user_param_random_subsection Random
The Random block is associated with a Util::Random object.  The only parameter this block is a "seed" for the Mersenne-Twister random number generator. The seed value must be an unsigned (non-negative) 32 bit integer, in the range 0 <= seed < 4294967296.

\subsection user_param_species_manager_subsection SpeciesManager

The SpeciesManager subsection contains a sequence of one or more polymorphic blocks, each of which contains the appropriate file format for a subclass of McMd::Species. Each such subclass describes a different class of molecules, and so requires a different file format. Instances of the base class McMd::Species use a file format that is flexible enough to describe any molecular structure. 

\subsection user_param_diagnostic_manager_subsection DiagnosticManager

The DiagnosticManager block contains a single integer parameter named baseInterval, followed by a sequence of polymorphic blocks associated with subclasses of McMd::Diagnostic.  Most subclasses of McMd::Diagnostic implement an operation that calculates one or more physical properties and either outputs data or carries out a statistical analysis, or both. Each diagnostic has an parameter named "interval" that specifies how often this operation should be invoked: Each diagnostic is invoked when the global step counter is an integer multiple of its interval parameter. The interval for each diagnostic must be a multiple of baseInterval.

\subsection user_param_mcsystem_subsection McSystem 
The format for an McSystem block, which is used only in MC simulations, is
\code
  McSystem{
    pairStyle      [string]
    bondStyle      [string]
    McPairPotential{
      ...
    }
    BondPotential{
      ...
    }
    EnergyEnsemble{
      ...
    }
    BoundaryEnsemble{
      ...
    }
  }
\endcode
The values of the pairStyle and bondStyle parameters are strings that specify the names of "interaction" classes that implement specific potential energy functions for nonbonded pair and covalent bond potentials, respectively. Interaction classes for non-bonded pair interactions are in the src/inter/pair directory. Interaction classes for bond potentials are in the src/inter/bond directory. For executables in which angle, dihedral, and/or external potentials have enabled (these are all disabled by default) these two "style" variables would be followed by "angleStyle", "dihedralStyle" and/or "externaStyle" string variables, as appropriate. 

The EnergyEnsemble and BoundaryEnsemble blocks are associated with instances of Util::EnergyEnsemble and Util::BoundaryEnsemble respectively. The EnergyEnsemble block specifies the type of statistical ensemble for energy fluctuations, which can be "adiabatic" (i.e., constant energy) or "isothermal". If the ensemble type is isothermal (as in the above example for mcSim), this this block must also contains a "temperature" parameter. Only "isothermal" makes sense for an MC simulation, but "adiabatic" ensemble is used for MD integrators that conserve energy or (for constant pressure ensembles) enthalpy. For isothermal simulations, temperature is specified as a value for kT, in units of energy. The BoundaryEnsemble block has a type parameter that can be either "rigid" (i.e., constant volume) or "isobaric". If this type is isobaric, the type parameter must be followed by a "pressure" parameter whose value specifies the target pressure in units of energy per volume.

The McPairPotential block contains the parameters required by the specific pairStyle (in this case, by the LJPair style), followed by a maxBoundary parameter. The maxBoundary parameter describes the dimensions of the largest expected dimensions of the periodic boundary.  The maxBoundary parameter is used only to allocate memory for a cell list. The CellList only allocates memory at the beginning of a simulation, and only allocates enough memory for the number of cells required by the combination of the maxBoundary and by the largest pair potential cutoff parameter.  In NVE and NVT simulations, maxBoundary can safely be chosen to be equal to or slightly larger than the actual rigid boundary dimensions. In NPT and NPH simulations, maxBoundary must be chosen large enough to guarantee that adequate memory is allocated for the CellList to allow for any fluctuation in system volume that may occur during a simulation. How conservative one must be depends on the system size and compressibility. The CellList does not occupy a large amount of memory, and so their is little cost in choosing a maxBoundary that is larger than necessary.

\subsection user_param_mdsystem_subsection MdSystem 

The format for an MdSystem block is:
\code
  McSystem{
    pairStyle      [string]
    bondStyle      [string]
    MdPairPotential{
      ...
    }
    BondPotential{
      ...
    }
    EnergyEnsemble{
      ...
    }
    BoundaryEnsemble{
      ...
    }
    MdIntegrator{
      ...
    }
  }
\endcode
In the above outline, the MdIntegrator{ ... } block denotes a polymorphic block that must contain the file format for a subclass of the McMd::MdIntegrator base class.

The only differences between an MdSystem block and an McSystem block are thus:
  
  - An MdSystem contains an MdPairPotential block where an McSystem contains an McPairPotential block. 
 
  - An MdSystem block contains an additional MdIntegrator block.

MC and MD simulations use the same potential classes for all bond potentials, and for angle, and dihedral, and external potentials (if enabled). Only the classes used to evaluate pair potentials differ. The same set of underlying interaction classes are used for all potentials, including the pair potential.
   
The parameter file format for an MdPairPotential is different from that for a McPairPotential because different internal data structures are used in MC and MD simulations to keep track of nonbonded neighbors. An McPairPotential uses a cell list (a instance of McMd::CellList), while an MdPairPotential uses a Verlet pair list (a Util::PairList). An McMd::PairList also contains an internal cell list, which is used periodically rebuild the pair list, but is not used for force or energy calculations.

The format for an MdPairPotential is:
\code  
   MdPairPotential{
      (Interaction parameters)
      maxBoundary   [string (boundary type)]  [float (dimension)] ...
      PairList{
         ...
      }
   }
\endcode
Here "(Interaction parameters)" represents whatever interaction parameters are required by the pair interaction class specified by the pairStyle (e.g., LJPair).  These have the same format as in an McPairPotential constructed with the same pairStyle. The maxBoundaryParameter also has the same format and purpose as in an McPairPotential (it is used to allocate the cell list).

The PairList subblock of an MdPairPotential contains additional parameters required to allocate memory for an instance of McMd::PairList. The format for this block is:
\code
      PairList{
        atomCapacity    [int]
        pairCapacity    [int]
        skin            [float]
      }
\endcode
The value of atomCapacity is the maximum number of distinct atoms.  The value of pairCapacity is the maximum number of distinct pairs within the Verlet list cutoff range. The Verlet list cutoff range is given by the sum of the largest pair potential cutoff plus the value of the "skin" parameter. 

The pair list in an mcSim simulation is rebuilt whenever one or more atoms in the simulation has moved a distance skin/2 or greater since the last time the pair list was rebuilt.  Increasing the value chosen for the "skin" parameter will thus generally cause the pair list to be rebuilt less frequently, but will increase the number of pairs retained in the pair list, and thus increase the cost of evaluating nonbonded forces that once every time step. There is thus an optimum value for each system. If the optimum value is not adequately known from previous experience, it can be identified by timing a few short trial simulations on a particular system with different values for the skin parameter.

\section param_DdMd_section Parameter Files for ddSim Simulations

Below is an example parameter file for a simple NVE ddSim parallel MD simulation for simulating a relatively small system (up 20000 atoms) on 8 processors in a 2 x 2 x 2 processor grid.  
\code
Simulation{
  Domain{
    gridDimensions    2    2    2
  }
  FileMaster{
    commandFileName   commands
    inputPrefix       in/
    outputPrefix      out/
  }
  nAtomType           1
  nBondType           1
  atomTypes           A    1.0
  AtomStorage{
    atomCapacity      12000
    ghostCapacity     12000
    totalAtomCapacity 20000
  }
  BondStorage{
    capacity          10000
    totalCapacity     20000
  }
  Buffer{
    atomCapacity       2000
    ghostCapacity      2000
  }
  pairStyle           LJPair
  bondStyle           HarmonicBond
  maskedPairPolicy    maskBonded
  reverseUpdateFlag   0
  PairPotential{
    epsilon           1.0
    sigma             1.0
    cutoff            1.122462048
    skin              0.4
    pairCapacity      40000
    maxBoundary       orthorhombic   30.0   30.0   30.0
  }
  BondPotential{
    kappa             400.0
    length            1.000
  }
  EnergyEnsemble{
    type              adiabatic
  }
  BoundaryEnsemble{
    type              rigid
  }
  NveIntegrator{
    dt                0.005
  }
  Random{
    seed              8012457890
  }
  DiagnosticManager{
     baseInterval     1000

     OutputEnergy{
        interval        1000
        outputFileName  energy
     }

     OutputPressure{
        interval        1000
        outputFileName  pressure
     }

  }
}
\endcode
This differs substantially from the mdSim and mcSim param files show previously. The main Simulation block is associated with a DdMd::Simulation object.In a ddSim simulation, there is only one main object; There is no analog of the MdSystem or McSystem blocks that appear in the mdSim and mcSim param files. 

In outline form, the format is
\endcode
Simulation{
  Domain{
    ...
  }
  FileMaster{
    ...
  }
  nAtomType           1
  nBondType           1
  atomTypes           A    1.0
  AtomStorage{
    ...
  }
  BondStorage{
    ...
  }
  Buffer{
    ...
  }
  pairStyle           LJPair
  bondStyle           HarmonicBond
  maskedPairPolicy    maskBonded
  reverseUpdateFlag   0
  PairPotential{
    ...
  }
  BondPotential{
    ...
  }
  EnergyEnsemble{
    ...
  }
  BoundaryEnsemble{
    ...
  }
  NveIntegrator{
    ...
  }
  Random{
    ...
  }
  DiagnosticManager{
     ...
  }
}
\endcode
This differs substantially from the mdSim and mcSim param files show previously. 

The main Simulation{} block is associated with a DdMd::Simulation object. There is no analog in a ddSim parameter file of the MdSystem or McSystem subblocks of the main simulation object that appear in the mdSim and mcSim param files. 

Some parameters and blocks are identical to those in mcSim and mdSim parameter files. The nAtomType, nBondType, atomTypes, pairStyle, bondStyle, and maskedPairPolicy parameters all have the same meaning as the corresponding parameters in mcSim and mdSim parameter files. The FileMaster, Random, EnergyEnsemble, and BoundaryEnsemble blocks are all associated with classes defined in the Util namespace, and so have formats identical to corresponding blocks in mcSim and mdSim parameter files.

\subsection user_param_Domain_subsection Domain
The Domain subsection defines a processor grid. In the domain decomposition algorithm, the periodic simulation cell is divided into a regular grid of subcells, or domains, each of which is assigned to a different processor. The gridDimensions parameter is a vector of 3 integers (a Util::IntVector) that defines the dimensions of this grid (the number of processors) along each of the three spatial directions (i.e., along x, y, and z for an orthorhombic boundary).

\subsection user_param_Storage_subection Storage Blocks
The AtomStorage and BondStorage blocks are associated with DdMd::AtomStorage and DdMd::BondStorage objects. An AtomStorage is a container that holds DdMd::Atom objects for one processor. A BondStorage is a container that instead holds objects that represent covalent bonds, each of which contains references to two atoms. The parameter file for a ddSim simulation with angle and dihedral potentials enabled would also have AngleStorage and DihedralStorage blocks associated with containers for 3-body and 4-body covalent groups.

An AtomStorage maintains separate lists of two types of atoms. Local atoms are atoms that are "owned" by a processor. "Ghost" atoms are atoms that are "owned" by neighboring processors, but that are close enough to the boundaries between processor domains to interact with atoms owned by this processor.

The storage classes allocate blocks of memory at the beginning of a simulation, using "capacity" parameters that are specified by the user. The atomCapacity and ghostCapacity parameters gives the maximum number of local atoms and ghost atoms that can be accomodated on a single processor. The totalAtomCapacity is the maximum value for the total number of atoms on all processors. In the BondStorage block, capacity parameter gives the maximum total number of bonds on one processor, and totalCapacity gives the total number of bonds on all processors. Bonds (and other covalent groups, if used) are maintained in a single list that contains every bond that involves at least one atom that is owned by the processor. 

The atomCapacity, ghostCapacity, and bondCapacity parameters must be chosen by the user to be large enough to accomodate any fluctuations in the number of atoms per processor. In a dense liquid containing a few thousand particles per processor, it is usually more than sufficient to set these capacities to be twice expected the average values, but a bit of experimentation is sometimes helpful. The totalAtomCapacity and totalBondCapacity must be greater tha or equal to than the total number of atoms or bonds, respectively, in the associated input configuration file. Using input values roughly twice these maximum values normally provides sufficient safety. 

The log output produced by a ddSim simulation lists the actual maximum number of local atom and ghost atoms encountered on any processor during a simulation. Before running large simulations of a particular system, it is useful to run some short simulations and use these reported maximum values as a guide (a lower bound) for choosing these capacity parameters.

\subsection user_param_Buffer_subection Buffer
The Buffer block is associated with a DdMd::Buffer object that provides a memory buffer that is used for interprocessor communication. The atomCapacity parameters specify the maximum number of local atoms that may be communicated between neighboring processors when ownership is exchanged (which occurs when the neighbor list is rebuilt, every ten time steps or so). The ghostCapacity specifies the maximum number of ghost atom positions to be communicated between neighboring processors.
 
The log output from a ddSim simulation can also list the actual maximum values for these quantities encountered during a test simulation. 

Navigation:
<ul style="list-style: none;">
 <li> \ref user_usage_page   (Previous) </li>
 <li> \ref user_page     (Up)   </li>
 <li> \ref user_commands_page  (Next) </li>
</ul>

*/
