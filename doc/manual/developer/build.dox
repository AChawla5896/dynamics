namespace McMd
{

/*! \page developer_build_page 6.1 Build System

\ref developer_standards_page  (Next)
<BR>

Simpatico is compiled using a system of unix makefiles.  All development was done using gnu make (gmake). 
  
\section make_files Source Directory
All C++ files for Simpatico, including both header (*.h) and source (*.cpp) files, are in subdirectories of the src/ directory.  The header and source file for each class are in the same directory. The name of each such file is the same as the class name, followed by the extension .h or .cpp.  All class names and corresponding file names are upper space camel (like Util::Vector or McMd::Species).  

The src/util, src/inter, src/mcMd, and src/ddMd directories each contain all the source files for a particular C++ namespace: 

 - src/util/ contains the Util namespace

 - src/inter/ contains the Inter namespace 

 - src/mcMd/ contains the McMd namespace

 - src/ddMd contains the DdMd namespace

These four directories will thus be referred to in what follows as "namespace" level directories. 

By convention, classes in the McMd and DdMd namespace may use names defined in the Util and Inter namespace, but classes in the DdMd namespace do not use names defined in the McMd namespace, and classes in the McMd namespace may not use names defined in the DdMd namespace. Classes in namespace Inter may use names defined in namespace Util, but not names defined in McMd or DdMd. We may summarize these relationships by speaking of one namespace being "dependent" on another: 

  - namespace Inter depends on namespace Util

  - namespace McMd depends on namespaces Inter and Util

  - namespace DdMd depends on namespaces Inter and Util

The main program mdSim.cpp and mcSim.cpp for single processor operation are in the src/mcMd directory.  The main program ddSim.cpp for parallel MD simulations is in the src/ddMd directory. 

Each of the namespace level source directories contains a subdirectory named tests/ that contains unit tests for classes in the associated name space. These unit tests are not automatically compiled or run by the build system that compiles the source code.

\section make_object Object Directories
Compiling a source file with extension *.cpp normally creates both an object file, with file name extension *.o, and a dependency file, with extension *.d. (The dependency file is not created if automatic dependency generation has been disabled.) These two generated files have the same base name as the corresponding source file, with the .cpp extension replaced by .o or .d. The dependency file is created as a side effect of compilation, and contains a makefile target that lists the header files that are included by the source file, along with other dependencies. 

The object and dependency file that are created by compiling a source file are normally placed in a directory outside of the src/ directory tree. This is referred to as an "out-of-source" build. It is also possible, however, to build a program within the src/ directory, by placing the object and dependency file in the same directory as the source file, thus executing an "in-source" build. The simpatico/obj/ directory contains two subdirectories, named obj/serial and obj/parallel, that can be used to hold object and dependency files created during an out-of-source build. The obj/serial directory is normally used to hold object files that are created during compilation of the single-processor versions of mcSim and mdSim. The obj/parallel/ directory is normally used to hold object files that are created during compilation the multi-processor versions of mdSim and mcSim (named mdSim_m and mcSim_m) and the ddSim parallel MD program, which all require MPI. 

In what follows, we will refer to the obj/serial, obj/parallel, and src/ directories collectively as object directories. Any of these three directories can be used to hold the object files that are generated during the process of building a program. The obj/serial and obj/parallel directories each contain a tree of subdirectories with the same structure as that of the src/ directory tree. When a source file from a directory in the src/ directory is compiled, the resulting object file and dependency file are placed in the analogous subdirectory of the relevant object directory tree. During an in-source build, the object and source directories are the same, and so the object and dependency files are thus placed in the same directory as the source file. 

After the setup script has been run, but before any code is compiled, each of the object directories contain the following files and subdirectories:
\code
   OBJ_DIR/
      makefile
      compiler.mk
      compiler.mk_r
      configure
      util/
      inter/
      mcMd/
      ddMd/
\endcode
Here we use the OBJ_DIR to represent the path to the relevant object directory.  The files in the main object directory OBJ_DIR have the following purposes:

   - makefile is the main makefile for building a program in a particular object directory.

   - compiler.mk is the main build configuration file. The file compiler.mk_r is a default repository version of compiler.mk. 

    - The configure file is a bash script that may be used to edit the build configuration files in order to enable or disable particular features.

Each of the four namespace level subdirectories (util/, inter/, mcMd/ and ddMd/) contains an additional set of files of the form:
\code
   namespace/
      makefile
      defines.mk
      defines.mk_r
      \tests
         makefile
\endcode
Here, we use "namespace/" to represent the namespace level directory name util/, inter/, mcMd/ or ddMd/. The files in each namespace level directory have the following purposes:

    - namespace/makefile defines an "all" target that compiles all of the source code in the corresponding subdirectory of src/, or the corresponding C++ namespace.

    - namespace/defines.mk file is a makefile fragment that specifies whether particular program features will be enabled or disabled in the code in the corresponding namespace. The defines.mk_r is a default repository version of the corresponding defines.mk file. 

The makefile system that is used to build the source code does not automatically compile or run the unit tests. Unit tsts for each namespace may be compiled by cd'ing to the tests/ subdirectory of the corresponding namespace-level directory and entering "make all", to compile all of the tests, followed by "make run" to run them. 

The obj/serial and obj/parallel directories are initially empty except for the files listed above. The same set of files also exist in the src/ directory, but appear there alongside source files and a variety of other files.  

\section make_configuration Build Configuration Files
The files named compiler.mk and defines.mk will be referred to in what follows as build configuration files. Each of these files is a makefile fragment that is created by the setup script by making a copy of the corresponding file with extension *.mk_r in the same directory.  These files are included by the object directory and namespace level makefiles. 

The compiler.mk file in each object directory defines variables that contain absolute paths to the source, object, and binary directories: 

   - SRC_DIR contains the absolute path to the simpatico/src/ directory. 
   - OBJ_DIR contains the absolute path to the object directory
   - BIN_DIR contains the absolute path to the directory in which executables are installed. 

The value of OBJ_DIR is always the path to the directory that contains the compiler.mk file. By default, BIN_DIR points to the simpatico/bin directory. These three paths are defined in terms of the value of a variable ROOT_DIR, which cotains an absolute path to the simpatico root directory. The value of ROOT_DIR is set to the correct value by the setup script. Here is an example of the relevant part of the file obj/serial/compiler.mk:
\code
ROOT_DIR=${PARENT}/simpatico
SRC_DIR=$(ROOT_DIR)/src
OBJ_DIR=$(ROOT_DIR)/obj/serial
BIN_DIR=$(ROOT_DIR)/bin
\endcode
Here, we have used ${PARENT} to represent an absolute path to the directory that contains the simpatico/ root directory. In the version of the file that is created by the setup script, this would be replaced by the literal absolute path to this parent directory. In the compiler.mk files in the obj/parallel and src/ directories, the value of OBJ_DIR would be set to ROOT_DIR/obj/parallel and ROOT_DIR/src, respectively. 

The "defines.mk" file in each of the namespace level subdirectories contains definitions of makefile variables that may be commented out to disable or uncommented to enable particular features of the code defined in the associated namespace. For example, the definition of a variable INTER_ANGLE in the file inter/defines.mk may be commented out to disable 3-body angle potentials or uncommented to enable angle potentials. Similarly, the definition of UTIL_DEBUG in the file util/defines.mk can commented out to disnable extra sanity checks that are intended for the debug version of the code, or uncommented to enable these checks. 

The "defines.mk" file in each namespace level subdirectory defines a variable with a name UTIL_DEFS, INTER_DEFS, MCMD_DEFS, or DDMD_DEFS for the defines.mk file in the util/, inter/, mcMd/, or ddMd/ directory, respectively. Each of these variables has a name of the form NAMESPACE_DEFS, where NAMESPACE represents an upper case form of the name of the corresponding C++ namespace, or of the associated directory. Each of these variables expands to a (possibly empty) string that can be passed to the compiler to define C++ preprocessor macros. Thus for example, if angle potentials are enabled by defining the makefile variable INTER_ANGLE in the file OBJ_DIR/inter/defines.mk, the variable INTER_DEFS will contain a string "-DINTER_ANGLE" that, when passed to the compiler as a command line option, causes the compiler to define a corresponding C++ macro named INTER_ANGLE. The C++ preprocessor macro INTER_ANGLE is used throughout the source files in the inter/, mcMd/ and ddMd/ directories to conditionally compile sections of code that are only relevant if angle potentials are enabled. Each of the four NAMESPACE_DEFS variables can define a specific set of preprocessor macros that may appear only in source code in the corresponding namespace and in namespaces that depends upon it. Thus for example, the preprocessor macros defined by the MCMD_DEFS string can only effect conditional compilation of source code in the McMd namespce, since no other namespace depends on the McMd namespace. Preprocessor macros defined by the UTIL_DEFS string, however, can effect source code in any of the four namespaces, since the Inter, McMd and DdMd namespaces all depend upon the Util namespace (i.e., may all use classes or other names that are defined in the Util namespace). 

The "configure" script in each object directory may be used programmatically edit the compiler.mk and defines.mk build configuration files so as to enable or disable specific compile-time program features. The configure script must be invoked from the main object directory that contains the script, using different options to enable or disable specific features. For example, the command to enable MPI is
\code
  ./configure -m1
\endcode
Here, the -m option denotes MPI, and the argument 1 is used to enable MPI, or 0 to disable MPI. The configure script in each object directory edits the build configuration files in the same directory.

\section make_main Top-Level Makefiles

The main makefile in each object directory (obj/serial, obj/parallel, and src/) has three primary targets named "mcMd", "mcSim-mpi" and "ddSim. 

  -"make mcMd" builds the single-processor mcSim and mdSim programs. 
  -"make mcMd-mpi" builds multi-processor versions of mcSim and mdSim.
  -"make ddMd" builds the ddSim program. 

Each of these primary targets places the object and dependency files in the object directory from which make was invoked and then installs the resulting executable file or files (by default) in the simpatico/bin/ directory. An in-source build can be executed (if desired) by invoking make with the appropriate target from within the src/ directory.

The simpatico/ root directory also has a master makefile with targets named "mcMd", "mcMd-mpi" and "ddSim". Invoking any of these targets from the root directory simply causes make to descend to the appropriate object directory (i.e., to obj/serial for serial programs and to obj/parallel for MPI programs) and then recursively invoke make with the same target from within this object directory. The relevant part of the makefile thus looks like this:
\code
all:
	make mcMd
	make mcMd-mpi
	make ddSim

mcMd:
	cd obj/serial; make mcMd

mcMd-mpi:
	cd obj/parallel; make mcMd-mpi

ddMd:
	cd obj/parallel; make ddMd
\endcode
The "all" target of the root directory makefile simply builds all three main makefile targets in sequence.

\section make_namespace Namespace Level Makefiles

Each of the object directories contains four namespace level subdirectories named util/, inter/, mcMd/ and ddMd/. Each of these namespace level subdirectories contains a makefile with an "all" target that compiles all of the source files in corresponding subdirectory of src/, or in the corresponding namespace.  In addition, the "all" target in each namespace level makefile creates a static library that contains the object files for all of the classes in that namespace.  Program executables are built by linking to these namespace level static libraries rather than by directly linking to the object files.The base name of each such library is given by "lib" followed by the namespace level directory name and a ".a" file extension. Each such library is placed in the namespace level subdirectory of the object directory. For example, the makefile in the OBJ_DIR/util/ subdirectory creates a static library that (by default) is named OBJ_DIR/util/libutil.a.  

The "all" targets in the makefiles in the OJB_DIR/mcMd and OBJ_DIR/ddMd subdirectories also compile associated main programs and create executables. Entering "make all" from the OBJ_DIR/mcMd directory compiles and links the main programs src/mcMd/mcSim.cpp and src/mcMd/mdSim.cpp to create mcSim and mdSim executables, in addition to compiling all of the required class files and building associated libraries.  Entering "make all" from src/ddMd compiles and links src/ddMd/ddSim.cpp to create the ddSim executable.

The "mcMd", "mcMd-mpi" and "ddMd" targets of the main object directory makefiles all use the configure script to first enable or disable MPI, as appropriate, and then recursively invoke the "all" targets of all of the namespace level makefiles required for the target program or programs. The relevant parts of the OBJ_DIR/makefile file in any of the three object directories all look like this:

\code

mcMd:
        ./configure -m0
        cd util;  make all
        cd inter; make all
        cd mcMd;  make all

mcMd-mpi:
        ./configure -m1
        cd util;  make all
        cd inter; make all
        cd mcMd;  make all

ddMd:
        ./configure -m1
        cd util;  make all
        cd inter; make all
        cd ddMd;  make all

\endcode
The command "./configure -m0" or "./configure -m1" uses the configure script in the same object directory to either disable ("./configure -m0") or enable ("./configure -m1") conditional compilation of parts of the code that use an MPI library. Note that the only difference between the the "mcMd" and "mcMd-mpi" targets is that the "mcMd" target disables MPI before compiling any source files, while "mcMd-mpi" enables MPI before compiling. The ddMd target always enables MPI, because it is essential to the functioning of the target program.

All of the real work thus done by the "all" targets of the namespace level makefiles in the util/, inter/, mcMd/ and ddMd/ subdirectorie of each object directory. Unlike the upper level makefiles in the simpatico/ root directory and in the object directories, the namespace level makefiles do not use a recursive make algorithm, i.e., they do not recursively invoke make in yet lower level subdirectories. 

\section make_sources Source File Lists

Every subdirectory of src/ at the namespace level and below contains a makefile fragment named "sources.mk". Each
such file defines defines a variable that contains a list of relative paths for all of the source files in that directory and all of its subdirectories (if any). In each subdirectory of src/, this variable has a name of the form [directory]_, where [directory] represents a mangled form of the subdirectory name. Specifically, [directory] is constructed by taking the path from the src/ directory to the subdirectory of interest and replacing each "/" directory separator by an underscore ("_"). For example, the file sources.mk in the namespace level directory src/util defines a variable util_ whose value is a list of all of the source files in the directory tree rooted at src/uti. The sources.mk file in subdirectory src/util/space defines a corresponding variable named util_space_. 

The value of the [directory]_ variable is a list of relative paths for all source files in the corresponding directory and its descendant subdirectories (excluding unit test directories), in which each path is expressed relative to the src/ directory.

The definition of a [directory]_ variable is straightforward in directories that contain source files but no subdirectories, such as the util/space directory. Here is the definition of util_space_ from the file src/util/space/sources.mk:
\code

util_space_=\
    util/space/Grid.cpp \
    util/space/IntVector.cpp \
    util/space/Tensor.cpp \
    util/space/Vector.cpp 

\endcode
The directory src/util/space contains four sources files named Grid.cpp, IntVector.cpp, Vector.cpp and Tensor.cpp, and has no subdirectories. 

In source directories that contain subdirectories, the source file list is constructed by combining corresponding lists defined in subdirectories. In each such directory, the file "sources.mk" in the parent directory must include the sources.mk files from all of subdirectories. The value of the [directory]_ variable for the parent directory is then constructed, wholely or in part, by concatenating values of the [subdirectory]_ variables defined in the subdirectories. For example, here is the definition of util_ from the file src/util/sources.mk:
\code

include $(SRC_DIR)/util/misc/sources.mk
include $(SRC_DIR)/util/format/sources.mk
include $(SRC_DIR)/util/containers/sources.mk
include $(SRC_DIR)/util/mpi/sources.mk
include $(SRC_DIR)/util/signal/sources.mk
include $(SRC_DIR)/util/param/sources.mk
include $(SRC_DIR)/util/math/sources.mk
include $(SRC_DIR)/util/space/sources.mk
include $(SRC_DIR)/util/random/sources.mk
include $(SRC_DIR)/util/boundary/sources.mk
include $(SRC_DIR)/util/crystal/sources.mk
include $(SRC_DIR)/util/ensembles/sources.mk
include $(SRC_DIR)/util/accumulators/sources.mk
include $(SRC_DIR)/util/archives/sources.mk

util_=$(util_misc_) $(util_format_) \
    $(util_containers_) $(util_mpi_) \
    $(util_signal_) $(util_param_) $(util_math_) \
    $(util_space_) $(util_random_) $(util_boundary_) \
    $(util_crystal_) $(util_ensembles_) \
    $(util_accumulators_) $(util_archives_)
\endcode
The first segment of the file is a set of include statements that include the sources.mk files from all subdirectories of src/util. The variable SRC_DIR contains the absolute path for the src/ directory. 

The sources.mk file in each subdirectory of src/ also defines two variables that expand into lists of absolute paths for source and object files. These variables have names of the form [directory]_SRCS and [directory]_OBJS, respectively. where [directory] again represents the mangled directory name. Thus, for example, the file src/util/sources.mk defines variables named util_SRCS and util_OBJS, in addition to util_. The [directory]_SRCS and [directory]_OBJS variables are constructed by using the gmake "addprefix" function to add absolute paths for the src/ and object directories as prefixes to each relative path in the [directory]_ variable. The relevant lines in the file src/util/sources.mk look like this: 
\code
util_SRCS=\
     $(addprefix $(SRC_DIR)/, $(util_))
util_OBJS=\
     $(addprefix $(OBJ_DIR)/, $(util_:.cpp=.o))
\endcode
Here, SRC_DIR expands to the absolute path to the simpatico/src directory and OBJ_DIR expands to the absolute path to the object directory. The only difference between the paths in a [directory]_ variable (e.g., util_) and those in a [directory]_SRCS variable (e.g., util_SRCS) is thus that the [directory]_ variable contains relative paths, relative to src/, while the [directory]_SRCS variable contains corresponding absolute paths. 

\section make_patterns Pattern Rules
Each namespace level directory of the src/ directory has a makefile fragment named "patterns.mk" that defines a pattern rule for compiling source files in that directory or namespace. The pattern rule has the same structure in all four namespace level directories, and look like this:

\code
$(OBJ_DIR)/%.o:$(SRC_DIR)/%.cpp
        $(CXX) $(CPPFLAGS) $(CXXFLAGS) $(INCLUDES) $(CPPDEFS) -c -o $@ $<
ifdef MAKEDEP
        $(MAKEDEP) $(INCLUDES) $(CPPDEFS) $(MAKE_DEPS) -S$(SRC_DIR) -B$(OBJ_DIR) $<
endif
\endcode

The target pattern requires that an object file with file extension *.o in a subdirectory of the object directory $(OBJ_DIR) can be created by compiling a *.cpp source file with the same base name in the corresponding subdirectory of the source directory $(SRC_DIR). The first command actually compiles the source file and creates the object file. The second command, which is within an ifdef MAKEDEP .. endif block, generates a dependency file as a side-effect of compilation. Automatic generation of dependency files can be disabled by commenting out the definition of the variable MAKEDEP in the compiler.mk file.

The following variables used in the above pattern are defined in the compiler.mk file file in the object directory from which make was invoked:
   
   - OBJ_DIR: Absolute path to the object directory
   - SRC_DIR: Absolute path to the simpatico/src directory
   - CXX: name of the C++ compiler executable
   - CPPFLAGS: flags for the C preprocessor
   - CXXFLAGS: general flags for the C++ compiler (optimization, warnings, etc.)
   - INCLUDES: directories to search for C++ header files, using the -I compiler option
   - MAKEDEP:  Name of the script to generate dependency files (bin/makeDep by default)

The same values are used for the above variables in all four namespaces. Two additional variables are defined within each patterns.mk file, and are assigned different values in different namespaces. These are:

   - CPPDEFS: String of all relevant C++ preprocessor macro definitions, defined using the compiler "-D" option
   - MAKE_DEPS: List of build configuration files that should  be listed as dependencies for object files in this namespace

The CPPDEFS variable is passed to the compiler, and contains a series of preprocessor macro definitions, defined using the "-D" option. Thus, for example, if debugging, bonds, and angles are enabled, and no other optional features, the value of CPPDEFS might expand within the file src/inter/defines.mk to
\code
CPPDEFS=-DUTIL_DEBUG -DINTER_BOND -DINTER_ANGLE
\endcode
The code used to define CPPDEFS and MAKE_DEPS within the file src/inter/patterns.mk is shown below as an example:
\code
# C preprocessor macro definitions
CPPDEFS=$(UTIL_DEFS) $(INTER_DEFS)

# Dependencies of source files in src/inter on makefile fragments
MAKE_DEPS= -A$(OBJ_DIR)/compiler.mk
MAKE_DEPS+= -A$(OBJ_DIR)/util/defines.mk
MAKE_DEPS+= -A$(OBJ_DIR)/inter/defines.mk
\endcode
The CPPDEFS variable expands to a concatenation of the NAMESPACE_DEFS variables (UTIL_DEFS, INTER_DEFS, etc.) for this namespace (i.e., INTER_DEFS) and for all namespaces upon which this depends (i.e., UTIL_DEFS). For the Inter namespace, this is a concatenation of $(UTIL_DEFS) and $(INTER_DEFS). This yields a string containing all of the preprocessor definitions that may be used by code in the corresponding namespace. 

The MAKE_DEPS variable contains a list of configuration files whose contents can effect the source code in this namespace. This list always contains the compiler.mk file, the defines.mk files for the namespace of interest, and the defines.mk files in any namespaces upon which this namespace depends. For the Inter namespace, MAKE_DEPS thus contains paths to the defines.mk files in the inter/ and util/ subdirectories. This list of files is added to the list of dependencies for every object file in this namespace, in addition to the usual list of header files, because changes to these build configuration files can change which preprocessor macros are defined, and thus can change the contents of the object files that are created by compilation.

\section make_dependency Dependency Files

If automatic dependency generation not disabled, a dependency file will be generated for each source file when the file is compiled, as a result of the second command in the pattern rule shown above. Each dependency file defines a makefile rule for constructing corresponding object (*.o) file target in the object directory. The rule consists of the name of the object file target followed by a colon and list of files upon which it depends, of the form 
\code

class.o: class.cpp class.h header1.h header2.h ....

\endcode
The list of dependencies for each object (*.o) file target includes the corresponding source (*.cpp) file, all of the header files that this source file directly or indirectly includes, and the list of configuration files given by the variable MAKE_DEPS. Though not shown in the above example, the paths to the target and all dependencies are actually given in dependency files as absolute paths. The makefile rule in each such file only lists dependencies, but does not contain an explicit command, because the required compiler command is given implicitly by a namespace-level pattern rule.

Dependency files are normally created automatically, as a side-effect of compilation, by the executable script simpatico/bin/makeDep. The pattern rules defined in the namespace level patterns.mk files apply the makeDep script to a source file whenever that file is compiled, and thereby regenerate the associated dependency file.  The "makeDep" script works by calling the gnu g++ compiler with the -MM option to calculate dependencies, and then using a separate python script to edit the resulting file by modifying the form of the paths for the target and dependency files. 

In each makefile at the namespace level and below, all relevant dependency files are included into the makefile by a command of the form
\code

-include $([directory]_OBJS:.o=.d)

\endcode
in which [directory] represents the mangled name of the directory containing the makefile. For example, in the file src/mcMd/mdSimulation, this line is
\code

-include $(mcMd_mdSimulation_OBJS:.o=.d)

\endcode
This line attempts to include a *.d dependency file for each *.o object file in the object file list. The dash in front of "include" instructs "make" to continue quietly if no dependency file is found for any of the object files listed in the object file list.

\section make_subdirectory Subdirectory Makefiles

As a convenience for developers, every subdirectory src/ at the namespace level and below contains a makefile that can be used to compile just the the source files in the directory tree rooted at that subdirectory. The "all" target of the makefile in each such directory does an in-source build of only the source files in that directory and its descendant subdirectories.

During development, the most convenient way to compile a source file that you have just modified is usually to just enter 
\code
  > make all
\endcode
from the directory that contains the new source file. If automatic dependency generation is enabled, and if you are working on only one class in that directory at a time, this will normally cause the build system to compile only the source file that you have modified.

Unfortunately, the file name conventions used in the build system make it difficult to explictly compile a single source file. The Simpatico build system uses absolute paths for all file paths. The "make" program is not smart enough to recognize when an absolute and relative path are equivalent.  As a result, the only way explicitly compile a single source file would be to use the absolute path to the object file as a makefile target. For example, if the absolute path to the root simpatico directory within a user account named "george" was "/home/george/simpatico/", you (or George) could compile the source file src/mcMd/simulation/Simulation.cpp by entering
\code 
  make /home/george/simpatico/src/mcMd/simulation/Simulation.o
\endcode 
from either the src/mcMd/simulation or the src/mcMd/ directory.   Most programmers are unwilling to type absolute paths, which is why we recommend just typing "make all" from the directory that contains the file of interest. To use "make all" in this way during development, however, you can only work on one file in each directory at a time. If a directory contains more than one incomplete or broken file, you simply need to comment out all but one of these (the one you are working on) in the value of the [directory]_ variable in the corresponding sources.mk file, until you are ready to complete or fix them.

<BR>
\ref developer_page  (Up)  &nbsp; &nbsp; &nbsp; &nbsp;
\ref developer_standards_page  (Next)

*/
}
