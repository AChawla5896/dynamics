namespace McMd
{

/*! \page developer_build_page 6.1 Build System

\ref developer_standards_page  (Next)
<BR>

Simpatico is compiled using a system of unix makefiles.  All development was done using gnu make (gmake). 
  
\section make_files Source Directory
All C++ files for simpatico, including both header (*.h) and source (*.cpp) files, are in the simpatico/src/ directory tree.  The header and source file for each class are in the same directory. The name of each C++ file is the same as the class name, followed by the extension .h or .cpp.  All class names and corresponding file names are upper space camel (like Util::Vector or McMd::Species).  

The src/util, src/inter, src/mcMd, and src/ddMd directories each contain all the source and header files for a particular C++ namespace: 

 - src/util/ contains the Util namespace

 - src/inter/ contains the Inter namespace 

 - src/mcMd/ contains the McMd namespace

 - src/ddMd contains the DdMd namespace

These four directories will be referred to in what follows as "namespace" level directories. 

When the implementation of one or more classes in one namespace use class names defined in a second namespace, the first namespace will be said to "depend" upon the second. The following dependencies exist among the four namespaces:

  - namespace Inter depends on namespace Util

  - namespace McMd depends on namespaces Inter and Util

  - namespace DdMd depends on namespaces Inter and Util

The build system assumes that these are the only inter-namespace dependencies. These conventions must thus be respected by any new code added to the system.

The src/mcMd and src/ddMd also contain main program files. The main programs mdSim.cpp and mcSim.cpp for single processor operation are in the src/mcMd directory.  The main program ddSim.cpp for parallel MD simulations is in the src/ddMd directory. 

Each of the namespace level source directories contains a subdirectory named tests/ that contains unit tests for classes in the associated name space. These unit tests are not automatically compiled or run by the build system that compiles the source code.

\section make_object Object Directories
Compiling a source file with file name extension *.cpp normally creates both an object file with extension *.o and a dependency file with extension *.d. (The dependency file is not created if automatic dependency generation is disabled.) The resulting object and dependency files the same base name as the corresponding source file, except for the file name extension. The dependency file contains a makefile target rule that lists all the files upon which the source file depends, including all the header files that it includes. 

When a *.cpp source file from a subdirectory of the src/ directory is compiled, the resulting object and dependency file are placed in the corresponding subdirectory of an object directory. The object directory must thus contain the same structure of subdirectories as the src/directory tree. When make is invoked from the simpatico/ root directory, all object and dependency files are placed in one two object file directories, which are both subdirectories of the simpatico/obj directory. Directory obj/serial is used to hold object and dependency files that are created by building the single processor mcSim and mdSim programs by invoking "make mcMd" from the root directory. Directory obj/parallel is used to hold all object and dependency files created by building the mdSim program, by invoking "ddSim" from the root directory, and those created by building multiprocessor versions of mcSim and mdSim, by invoking "make mcMd-mpi" from the root directory. Directories obj/parallel and obj/serial each contain a tree of subdirectories similar to that of the src/ directory, but are initially almost empty except for a few makefiles and makefile fragments.

Any of the simpatico programs can be build either by invoking make from the simpatico/ root directory, as described above, or by descending (cd'ing) to the an object directory (obj/serial for serial programs or obj/parallel for parallel programs) and invoking make with the appropriate target (mcMd, mcMd-mpi, or ddMd) from there. In addition, one may execute an "in-source" build, in which each object and dependency file is placed alongside the corresponding source files within the src/ directory, by invoking make from the src/ directory, using the same set of primary make targets ("make mcMd", "make mcMd-mpi" or "make ddMd").  In what follows, we will thus refer to the obj/serial, obj/parallel, and src/ directories collectively as object directories, since any of them can be used for this purpose.

\section make_configuration Build Configuration Files
After the setup script has been run, but before any source code has has been compiled, each of the three object directories contain the following files and subdirectories:
\code
   OBJ_DIR/
      makefile
      config.mk
      config.mk_r
      configure
      util/
      inter/
      mcMd/
      ddMd/
\endcode
Here we use the OBJ_DIR to represent the path to the relevant object directory. The purposes of the files in this directory are:

   - makefile is the main makefile for a particular object directory.

   - config.mk is the main build configuration file for that object directory.

   - config.mk_r is a default repository version of config.mk. 

   - configure is a bash script that can be used to enable or disable specific features before compiling

Each of the four namespace level subdirectories (util/, inter/, mcMd/ and ddMd/) contains a similiar set of files, of the form:
\code
   namespace/
      makefile
      config.mk
      \tests
         makefile
\endcode
Here, we use "namespace/" to represent the namespace level directory name, util/, inter/, mcMd/ or ddMd/. The relevant files in each namespace level directory:

   - namespace/makefile is the main makefile for a single C++ namespace. 

   - namespace/config.mk file is a build configuration file for a single namespace.

The makefile in each namespace level subdirectory contains an "all" target that compiles all of the source files in the corresponding subdirectory of src/ and builds a static library that contains all of the resulting objects.

After setup, but before compilation, the obj/serial and obj/parallel directories are initially empty except for the files listed above. The same set of files also exist in the src/ directory, alongside a variety of other files.  Each namespace level directory in the src/ directory also contains a file named compiler.mk_r, which is a default repository version of the corresponding namespace level config.mk file.

The config.mk files in the object directory and its subdirectories will be referred to in what follows as build configuration files. Each config.mk file is a makefile fragment that is created by the setup script by making a copy of a repository version, which is a file of the same name with extension *.mk_r. The build configuration files are included by the object directory and namespace level makefiles, and determine what options will be passed to the compiler, including options that define C++ preprocessor macros, and thus determine which features will be enabled or disabled when a program is compiled. Each object directory contains a complete set of build configuration files, which determine the configuration of any program built in that directory. Users may modify the build configuration file, either manually or using the ./configure script in the same object directory, but should avoid modifying the corresponding repository files, which are named config.mk_r. 

The makefile system that is used to build the source code does not automatically compile or run the unit tests in the namespace/tests directory. Unit tests for each namespace may be compiled by cd'ing to the namespace/tests subdirectory of the relevant namespace-level directory, and invoking make from there. Entering "make all" compiles all tests for that namespace. Entering "make run" will run them. 

\section make_config.mk Main build configuration file
The main config.mk in each object directory is the main build configuration file for that directory. It defines makefile variables that contain paths to the source, object and binary directories, and other variables that define the choice of compiler and various compiler options.

The following variables defined in the main config.mk file define paths: 

   - SRC_DIR contains the absolute path to the simpatico/src/ directory. 
   - OBJ_DIR contains the absolute path to the object directory.
   - BIN_DIR contains the absolute path to the directory in which executables are installed. 

In the config.mk file within each object directory, OBJ_DIR expands to the absolute path for that object directory. By default, BIN_DIR points to the simpatico/bin directory. The values of the above three variables are expressed in terms of a variable ROOT_DIR that contains the absolute path to the simpatico/ root directory. The correct value for ROOT_DIR is set by the setup script. Here is an example of the relevant part of the file obj/serial/config.mk:
\code
ROOT_DIR=PARENT/simpatico
SRC_DIR=$(ROOT_DIR)/src
OBJ_DIR=$(ROOT_DIR)/obj/serial
BIN_DIR=$(ROOT_DIR)/bin
\endcode
Here, PARENT is used represent an absolute path to the directory that contains the simpatico/ root directory. In the actual file, this would be replaced by the literal absolute path to this parent directory. In the config.mk files in the obj/parallel and src/ directories, the value of OBJ_DIR would be set to ROOT_DIR/obj/parallel and ROOT_DIR/src, respectively. 

\section make_config.mk Namespace build configuration files

The "config.mk" file in each of the namespace level subdirectories of an object directory contains definitions of makefile variables that may be commented out to disable or uncommented to enable particular features of the code defined in the associated namespace. For example, the definition of a variable INTER_ANGLE in the file inter/config.mk may be commented out to disable 3-body angle potentials or uncommented to enable angle potentials. Similarly, the definition of UTIL_DEBUG in the file util/config.mk can commented out to disnable extra sanity checks that are intended for the debug version of the code, or uncommented to enable these checks. 

Each such file defines a variable with a name of the form NAMESPACE_DEFS, in which NAMESPACE represents an upper case form of the name of the associated C++ namespace (i.e., UTIL, INTER, MCMD, or DDMD). Thus, util/config.mk defines a variable named UTIL_DEFS, inter/config.mk defines INTER_DEFS, mcMd/config.mk defines MCMD_DEFS, and ddMd/config.mk defines DDMD_DEFS. Each such makefile variables expands to a (possibly empty) string of compiler options that define C++ preprocessor macros, using the compiler "-D" option. Thus for example, if angle potentials are enabled by defining the makefile variable INTER_ANGLE in the file OBJ_DIR/inter/config.mk, the variable INTER_DEFS will contain a string "-DINTER_ANGLE" that, when passed to the compiler, defines a corresponding C++ preprocessor macro named INTER_ANGLE. Preprocessor macros that are defined in namespace level config.mk file are only used in the source code of the corresponding namespace and in other namespace(s) that depends upon it. Thus for example, preprocessor macros defined by the MCMD_DEFS string only appear in the McMd namespce, but preprocessor macros defined by the UTIL_DEFS can appear in any of the four C++ namespaces, since the Inter, McMd and DdMd namespaces all depend upon the Util namespace.

\section make_config_script Configure script

Each main object directory also contains a bash script named "configure". This script may be used to edit the configuration files in that directory from the command line, in order to enable or disable specific features. The configure script must be invoked from the main object directory (the directory that contains the script), and uses specific command line options to enable or disable specific features. For example, the command to enable MPI is
\code
  ./configure -m1
\endcode
and corresponding command to disable MPI is "./configre -m0".  Here, the -m option denotes MPI, while the argument 1 is used to enable MPI, or an argument 0 to disable MPI. The configure script in each object directory edits only the build configuration files in the same directory tree.

\section make_main Root Directory Makefile

The makefile in the simpatico/ root directory contains four primary targets named "mcMd", "mcSim-mpi", "ddSim", and "all":

  -"make mcMd" builds the single-processor mcSim and mdSim programs. 
  -"make mcMd-mpi" builds multi-processor versions of mcSim and mdSim.
  -"make ddMd" builds the ddSim program. 
  -"make all" build all of the serial and parallel programs in the package

This top level makefile is recursive: The commands associated with the "mcMd", "mcMd-mpi" and "ddMd" targets in this makefile each command make to descend to an appropriate object directory (i.e., to obj/serial for serial programs and to obj/parallel for MPI programs) and then recursively invoke make with the same target from within that object directory. The relevant part of the makefile in the root directory thus looks like this:
\code
all:
	make mcMd
	make mcMd-mpi
	make ddSim

mcMd:
	cd obj/serial; make mcMd

mcMd-mpi:
	cd obj/parallel; make mcMd-mpi

ddMd:
	cd obj/parallel; make ddMd
\endcode
The default "all" target simply invokes the other three targets, thus building all of the programs in the package.

\section make_object_makefile Object Directory Makefile
The main makefile in each object directorY also contains three targets named "mcMd", "mcMd-mpi" and "ddMd". These three targets exist in all three makefiles. Invoking make one of these primary targets from any object file directory will cause the corresponding program(s) to be built in the object directory from which make was invoked, using the build configuration files in that directory, and cause the executable or executables to be installed in directory BIN_DIR.

The primary "mcMd", "mcMd-mpi" and "ddMd" targets of each object directory makefile are also recursive. The associated list of commands for each of them first invokes the configure script to enable or disable MPI, as appropriate, and then descends to the namespace level directory for each namespace that is required to build the target program or programs, invoking "make all" from within each such namespace sub-directory. The key part of the main makefile file in each object directory thus looks like this:
\code

mcMd:
        ./configure -m0
        cd util;  make all
        cd inter; make all
        cd mcMd;  make all

mcMd-mpi:
        ./configure -m1
        cd util;  make all
        cd inter; make all
        cd mcMd;  make all

ddMd:
        ./configure -m1
        cd util;  make all
        cd inter; make all
        cd ddMd;  make all

\endcode
The command "./configure -m0" or "./configure -m1" uses the configure script to either disable ("./configure -m0") or enable ("./configure -m1") conditional compilation of parts of the code that use an MPI library. Note that the only difference between the the "mcMd" and "mcMd-mpi" targets is that the "mcMd" target disables MPI before compiling any source files, while "mcMd-mpi" enables MPI before compiling. The ddMd target always enables MPI, because MPI is essential to the functioning of the ddSim target program.

\section make_namespace_makefile Namespace Level Makefiles

The makefile in each namespace level subdirectories of each object directory defines an "all" target that compiles all of the source files in corresponding subdirectory of src/, or the corresponding namespace.  In addition, this "all" target creates a static library that contains the object files for all of the classes in that namespace.  Program executables are built by linking to these namespace level static libraries rather than by directly linking to the object files.The base name of each such library is given by a prefix "lib" followed by the namespace level directory name with a ".a" file extension. Each such library is placed in the corresponding namespace level object directory. For example, the makefile in the util/ subdirectory creates a static library that (by default) is named OBJ_DIR/util/libutil.a.  

The "all" targets of the makefiles in the OJB_DIR/mcMd and OBJ_DIR/ddMd subdirectories also compile associated main programs and install the resulting executables in the BIN_DIR directory. Entering "make all" from the OBJ_DIR/mcMd directory compiles and links the main programs src/mcMd/mcSim.cpp and src/mcMd/mdSim.cpp to create the mcSim and mdSim executables, in addition to compiling all of the required class files.  Similarly, entering "make all" from the ddMd/ object subdirectory compiles and links src/ddMd/ddSim.cpp to create the ddSim executable.

Unlike higher level makefiles, the namespace level makefiles are not recursive, i.e., they do not recursively invoke make in yet lower level subdirectories. The "all" target in each namespace-level directory instead compiles all files in a list of source files for that namespace.

\section make_sources Source File Lists

Every subdirectory of src/ (other than the tests/ directories) contains a makefile fragment named "sources.mk". Each such file defines a variable that contains a list of the source files in that directory and all of its subdirectories (if any). In each such subdirectory of src/, this variable has a name of the form [directory]_, where "[directory]" represents a mangled form of the subdirectory name. Specifically, [directory] is constructed by taking the path from the src/ directory to the subdirectory of interest and replacing each "/" directory separator by an underscore ("_"). For example, the file src/util/sources.mk defines a variable util_ that expands to a list of all of the source files in the directory tree rooted at src/util. The file src/util/space/sources.mk defines a corresponding variable named util_space_.  The value of the [directory]_ variable is a list of relative paths for all source files in the corresponding directory and its descendant subdirectories, in which each path is expressed relative to the src/ directory.

The code that defines a [directory]_ variable is straightforward in directories that contain source files but no subdirectories, such as the util/space directory. For example, here is the definition of util_space_ from the file src/util/space/sources.mk:
\code

util_space_=\
    util/space/Grid.cpp \
    util/space/IntVector.cpp \
    util/space/Tensor.cpp \
    util/space/Vector.cpp 

\endcode
The directory src/util/space contains four sources files named Grid.cpp, IntVector.cpp, Vector.cpp and Tensor.cpp, and has no subdirectories. 

In source file directories that contain subdirectories, the source file list is constructed by concatenating corresponding lists defined in the subdirectories. In this case, the "sources.mk" file in the parent directory must include the sources.mk files from all of subdirectories. The value of the [directory]_ variable for the parent directory is then constructed by concatenating values of the [subdirectory]_ variables defined in the subdirectories, and then adding additional source files from the parent directory, if any. For example, here is the makefile code that defines the variable util_ in the file src/util/sources.mk:
\code

# Include subdirectory sources.mk files
include $(SRC_DIR)/util/misc/sources.mk
include $(SRC_DIR)/util/format/sources.mk
include $(SRC_DIR)/util/containers/sources.mk
include $(SRC_DIR)/util/mpi/sources.mk
include $(SRC_DIR)/util/signal/sources.mk
include $(SRC_DIR)/util/param/sources.mk
include $(SRC_DIR)/util/math/sources.mk
include $(SRC_DIR)/util/space/sources.mk
include $(SRC_DIR)/util/random/sources.mk
include $(SRC_DIR)/util/boundary/sources.mk
include $(SRC_DIR)/util/crystal/sources.mk
include $(SRC_DIR)/util/ensembles/sources.mk
include $(SRC_DIR)/util/accumulators/sources.mk
include $(SRC_DIR)/util/archives/sources.mk

# Concatenate subdirectory source file lists
util_=$(util_misc_) $(util_format_) \
    $(util_containers_) $(util_mpi_) \
    $(util_signal_) $(util_param_) $(util_math_) \
    $(util_space_) $(util_random_) $(util_boundary_) \
    $(util_crystal_) $(util_ensembles_) \
    $(util_accumulators_) $(util_archives_)

\endcode
The first segment of the file is a set of include statements that include the sources.mk files from all subdirectories of src/util. The definition of util_ simply concatenates the corresponding source file lists for all subdirectories.

The sources.mk file in each such subdirectory of src/ also defines two variables that expand into lists of absolute paths for all source and object files in that subdirectory and its descendants. These variables have names of the form [directory]_SRCS and [directory]_OBJS, respectively, where [directory] again represents the mangled directory name. Thus, for example, the file src/util/sources.mk defines variables named util_SRCS and util_OBJS, in addition to util_. The [directory]_SRCS and [directory]_OBJS variables are constructed by using the gmake "addprefix" function to add absolute paths for the source and object directories as prefixes to each relative path in the [directory]_ variable. The relevant lines in the file src/util/sources.mk look like this: 
\code
util_SRCS=\
     $(addprefix $(SRC_DIR)/, $(util_))
util_OBJS=\
     $(addprefix $(OBJ_DIR)/, $(util_:.cpp=.o))
\endcode
Here, SRC_DIR expands to the absolute path to the simpatico/src directory and OBJ_DIR expands to the absolute path to the object directory. Note that the only difference between the paths in a [directory]_ variable (e.g., util_) and those in a [directory]_SRCS variable (e.g., util_SRCS) is that the [directory]_ variable contains relative paths, relative to src/, while the [directory]_SRCS variable contains corresponding absolute paths. 

\section make_patterns Pattern Rules
Each namespace level subdirectory of the src/ directory has a makefile fragment named "patterns.mk" that defines a pattern rule for compiling source files in that directory or namespace. The pattern rule has the same structure in all four namespace level directories. In each case, the rule looks like this:
\code
$(OBJ_DIR)/%.o:$(SRC_DIR)/%.cpp
        $(CXX) $(CPPFLAGS) $(CXXFLAGS) $(INCLUDES) $(DEFINES) -c -o $@ $<
ifdef MAKEDEP
        $(MAKEDEP) $(INCLUDES) $(DEFINES) $(MAKE_DEPS) -S$(SRC_DIR) -B$(OBJ_DIR) $<
endif
\endcode
The target pattern requires that an object file target with file extension *.o in a subdirectory of the object directory $(OBJ_DIR) can be created by compiling a *.cpp source file with the same base name in the corresponding subdirectory of the source directory $(SRC_DIR). The first command actually compiles the source file and creates the object file. The second command, which is within an ifdef MAKEDEP .. endif block, generates a dependency file as a side-effect of compilation. Automatic generation of dependency files can be disabled by commenting out the definition of the variable MAKEDEP in the config.mk file.

The following variables used in the above pattern are defined in the config.mk file file in the object directory from which make was invoked:
   
   - OBJ_DIR: Absolute path to the object directory
   - SRC_DIR: Absolute path to the simpatico/src directory
   - CXX: name of the C++ compiler executable
   - CPPFLAGS: flags for the C preprocessor
   - CXXFLAGS: general flags for the C++ compiler (optimization, warnings, etc.)
   - INCLUDES: directories to search for C++ header files, using the -I compiler option
   - MAKEDEP:  Name of the script to generate dependency files (bin/makeDep by default)

The same values are used for the above variables in all four namespaces. Two additional variables are defined within each patterns.mk file, and are assigned different values in different namespaces. These are:

   - DEFINES: String of all relevant C++ preprocessor macro definitions, defined using the compiler "-D" option
   - MAKE_DEPS: List of build configuration files that should  be listed as dependencies for all object files in this namespace

The DEFINES variable, if not empty, contains a series of preprocessor macro definitions, defined using the "-D" option. Thus, for example, if debugging, bonds, and angles are enabled, and no other optional features, the value of DEFINES within the file src/inter/patterns.mk might expand to
\code
DEFINES=-DUTIL_DEBUG -DINTER_BOND -DINTER_ANGLE
\endcode
The definitions of DEFINES and MAKE_DEPS within the file src/inter/patterns.mk are shown below as an example:
\code
# C preprocessor macro definitions
DEFINES=$(UTIL_DEFS) $(INTER_DEFS)

# Dependencies of source files in src/inter on makefile fragments
MAKE_DEPS= -A$(OBJ_DIR)/config.mk
MAKE_DEPS+= -A$(OBJ_DIR)/util/config.mk
MAKE_DEPS+= -A$(OBJ_DIR)/inter/config.mk
\endcode
The DEFINES variable is constructing by concatenating the NAMESPACE_DEFS variables (UTIL_DEFS, INTER_DEFS, etc.) for this namespace (i.e., INTER_DEFS) and for all namespaces upon which this namespace depends (i.e., UTIL_DEFS). For the Inter namespace, this yields a concatenation of $(UTIL_DEFS) and $(INTER_DEFS). The resulting string contains all of the preprocessor definitions that are allowed to be used by code in this namespace. 

The MAKE_DEPS variable contains a list of build configuration files whose contents can effect compilation of source code in this namespace. This list always contains the main config.mk file from the parent object directory, the config.mk file for the namespace of interest, and config.mk files for any namespace(s) upon which this namespace depends. For the Inter namespace, MAKE_DEPS thus contains paths to the config.mk files in the inter/ and util/ subdirectories. These build configuration files are added to the list of dependencies for every object file in this namespace because changes to these config.mk files can change which preprocessor macros are defined or which compiler options are set, and thus can change the contents of the resulting object files.

\section make_dependency Dependency Files

If automatic dependency generation is not disabled, a dependency file will be generated for each source file whenever the file is compiled, as a result of the second command in the pattern rule shown above. Each dependency file defines a makefile rule for constructing the corresponding object file. This rule can be used to determine when the source file needs to be recompiled as a result of changes in the files upon which it depends. The rule consists of the name of the object file target followed by a colon and list of files upon which it depends, of the form 
\code

class.o: class.cpp class.h header1.h header2.h ....

\endcode
The list of dependencies for each object (*.o) file target includes the corresponding source (*.cpp) file, all of the header files that this source file directly or indirectly includes, and the list of configuration files given by the variable MAKE_DEPS. Though not shown in the above example, all paths to the target and its dependencies are actually given in dependency files as absolute paths. Each such makefile rule only lists dependencies, but does not contain an explicit command, because the required compiler command is given implicitly by the appropriate pattern rule. 

Dependency files are created by the bash script simpatico/bin/makeDep. The pattern rules defined in the namespace level patterns.mk files apply the makeDep script to a source file whenever that file is compiled.  The "makeDep" script works by calling the gnu g++ compiler with the -MM option to determine dependencies, and using a separate python script to edit the resulting file.

In each makefile at the namespace level and below, all relevant dependency files are included into the makefile by a command of the form
\code

-include $([directory]_OBJS:.o=.d)

\endcode
in which [directory] represents the mangled name of the directory containing the makefile. For example, the file src/mcMd/makefile contains a line 
\code

-include $(mcMd_OBJS:.o=.d)

\endcode
This command attempts to include a *.d dependency file for each *.o object file in the object file list. The dash in front of "include" instructs "make" to continue quietly if no dependency file is found for any object file target.

\section make_subdirectory Subdirectory Makefiles

As a convenience for developers, every subdirectory of the namespace level directories of src/ contains its own makefile. The "all" target of each such subdirectory makefile executes an in-source build of the files in that subdirectory and any descendant subdirectories.  During development, the most convenient way to test whether a source file that you have just modified compiles correctly is usually to just enter 
\code
  > make all
\endcode
from the directory that contains the new or newly modified source file. If automatic dependency generation is enabled, and if you are modifying one class in that directory at a time, this will normally cause the build system to compile only the source file that you have just modified. If a directory contains more than one incomplete or broken file, should temporarily comment out all but one of these files (the one you are working on) in the value of the [directory]_ variable in the corresponding sources.mk file, and uncomment each such file when you are ready to work on it.

The file name conventions used in the Simpatico build system make it awkward for a user to explictly request compilation of a specific source file. The build system uses absolute paths for all file paths. The "make" program is not smart enough to recognize when an absolute and relative path are equivalent.  As a result, the only way explicitly request compilation of a specific source file is to use the absolute path to the object file as a makefile target. For example, if the absolute path to the root simpatico directory within a user account named "george" was "/home/george/simpatico/", you (or George) could compile the source file src/mcMd/simulation/Simulation.cpp in-source by entering
\code 
  make /home/george/simpatico/src/mcMd/simulation/Simulation.o
\endcode 
from either the src/mcMd/simulation or the src/mcMd/ directory.   Most programmers are unwilling to repeatedly type absolute paths, which is why we recommend simply using "make all" from the directory that contains the file of interest. 

<BR>
\ref developer_page  (Up)  &nbsp; &nbsp; &nbsp; &nbsp;
\ref developer_standards_page  (Next)

*/
}
