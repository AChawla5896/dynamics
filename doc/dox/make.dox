namespace McMd
{

/*! \page make_page Makefiles

Simpatico is compiled using a system of unix makefiles.  All development was done using gnu make (gmake). We have never checked if the build system works with other variants of make (though it very well might).
  
\section make_main Source File and Namespace Conventions
All C++ files for Simpatico, including both header (*.h) and source (*.cpp) files, are in subdirectories of the src/ directory.  The header and source file for each class are in the same directory. The name of each such file is the same as the class name, followed by the extension .h or .cpp.  All class names and corresponding file names are upper space camel (like Util::Vector or McMd::FileMaster).  When each source file is compiled, the resulting object (*.o) file is placed in the same directory as the source file, using the same base name, with a .o extension.  When automatic dependency generation is enabled, a dependency file with the same base name and a suffix *.d is also created for each source file as a side effect of compilation.

The src/util, src/inter, src/mcMd, and src/ddMd directories each contain the code for a different C++ namespace: 

 - src/util/ contains the Util namespace

 - src/inter/ contains the Inter namespace 

 - src/mcMd/ contains the McMd namespace

 - src/ddMd contains the DdMd namespace

These four directories will thus be referred to in what follows as "namespace" level directories. 

By convention, classes in the McMd and DdMd namespace may use names defined in the Util and Inter namespace, but classes in the DdMd namespace do not use names defined in the McMd namespace, and classes in the McMd namespace may not use names defined in the DdMd namespace. Classes in namespace Inter may use names defined in namespace Util, but not names defined in McMd or DdMd. We may summarize these relationships by speaking of one namespace being "dependent" on another: 

  - namespace Inter depends on namespace Util
  - namespace McMd depends on namespaces Inter and Util
  - namespace DdMd depends on namespaces Inter and Util

The main program mdSim.cpp and mcSim.cpp for single processor operation are in the src/mcMd directory.
The main program ddSim.cpp for parallel MD simulations is in the src/ddMd directory. 

\section make_main Main makefile 

The file src/makefile is the main makefile. It has two main makefile targets, "mcMd" and "ddMd".  The "mcMd" target builds the mcSim and mdSim executables. The "ddMd" target builds the ddSim parallel MD executable. 

Entering "make mcMd" from the src/ directory will:

 - Compile all of the source (*.cpp) files in the util/, inter/, 
   and mcMd/ subdirectories, creating corresponding object (*.o) 
   files,

 - Construct three static library (*.a) files from the resulting 
   object files, each of which contains the code from one namespace.

 - Compile the programs src/mcMd/mcSim.cpp and src/mcMd/mdSim.cpp,
   and link them with three libraries to create a pair of executable 
   programs for MC and MD simulation. 

By default, the resulting library files are placed in the simpatico/lib/ directory, and the executable files are placed in the simpatico/bin/ directory.  

Entering "make ddMd" from the src/ directory instead compiles (or recompiles) all of the source code from the util/, inter/, and ddMd/ directories, creates three corresponding library files in simpatico lib/ directory, and creates an executable (by default) named ddSim in the simpatico/bin directory.

The "mcMd" annd "ddMd" targets of the main src/makefile both use recursive make: The commands associated with these targets simply descend into to each of the namespace level subdirectories of src/ and invoke "make all" from within each such subdirectory.

\section make_namespace Namespace Level Makefiles 

Each of the namespace level directories src/util, src/inter, src/mcMd and src/ddMd has a makefile with an "all" target that:

  - compiles all of the class source files in the associated directory tree, or in the associated namespace
  - builds a static library that contains compiled object code for all classes in that namespace. 

The "all" targets in the src/mcMd and src/ddMd namespace level makefiles also build executables. Invoking "make all" from src/mcMd compiles the main programs src/mcMd/mcSim.cpp and src/mcMd/mdSim.cpp and builds the mcSim and mdSim executables. Invoking "make all" from src/ddMd compiles src/ddMd/ddSim.cpp and builds the ddSim executable. 

Each namespace level directory has three makefile fragments named "patterns.mk", "sources.mk" and "defines.mk". In each such directory:

 - patterns.mk defines a pattern rule for compiling all source files in the associated namespace

 - sources.mk defines makefile variables that list all of the class source (*.cpp) and object (*.o) files in the namespace 

- defines.mk file defines preprocessor macros that effects conditional compilation of files in that namespace.

The makefile in each namespace level directory includes the src/compiler.mk file, and the three makefile fragments listed from the same directory. The makefile in each namespace level directory also include sources.mk and defines.mk files from any other namespaces upon which the associated namespace depends. For example, because the McMd namespace "depends" upon the Util and Inter namespaces, the file src/mcMd/makefile includes the sources.mk and defines.mk files from the src/inter and src/util directories, in addition to those from the src/mcMd directory.

The sources.mk file in each namespace level directory defines a variable whose name ends with _SRCS that lists allof the class source (*.cpp) files in the associated directory tree or namespace, and variable whose name ends with _OBJS that lists names of all the object (*.o) files that should be created by compiling these files. The names of these makefile variables are constructed by appending suffixes _SRCS and _OBJS to the directory names util, inter, mcMd and ddMd. For example, in the file src/mcMd/sources.mk, these variables are named mcMd_SRCS and mcMd_OBJS, respectively. The "all" target of each namespace level makefile makes all of the object files listed in the corresponding _OBJS variable and builds a library from them.

\section make_sources Subdirectory Makefiles

Every subdirectory in the directory tree rooted at a namespace level directory contains a makefile. The makefile in each such directory has an "all" target that compiles all of the class source files in the sub-tree rooted at that directory. Each such makefile includes the same set of makefile fragments as those included in the corresponding namespace level makefile. 

Every directory at the namespace level and below also contains a "sources.mk" makefile fragment. Each sources.mk file defines a pair of variables defines two variables with names of the form [directory]_SRCS and [directory]_OBJS, analogous to the _SRCS and _OBJS variables in the namespace level file. Here, [directory] is a mangled form of the directory name that is constructed by taking the path from the src/ directory to the subdirectory of interest and replacing each "/" directory separator by an underscore ("_").  For example, the file src/util/param/sources.mk defines variables util_param_SRCS and util_param_OBJS. In each such directory, the value of [directory]_SRCS is a list of paths to the all of the source (*.cpp) files in the directory tree rooted at the specified directory. The value of [directory]_OBJS variable is a list of the paths for all of the corresponding *.o object files.  As a special case of this, the namespace level makefiles define variables that contain lists of all of the source files in a namespace. For example, src/util/sources.mk defines variables util_SRCS and util_OBJS that contain lists of the paths for all of the source files and and object file targets in the util/ directory and its subdirectories.

Theses lists of source files are constructed recursively, by concatenating corresponding lists defined in subdirectories.  In each source code directory that contains subdirectories, the parent directory "sources.mk" file includes the sources.mk file from each of its subdirectories. The value of the [directory]_SRCS variable for the parent directory is then constructed by concatenating values of the [subdirectory]_SRCS variables defined in the subdirectories, and then adding paths for any source files in the parent directory. Take a look at a few sources.mk files to see how this works.

The [directory]_OBJS variable in each sources.mk file is defined using a substitution pattern that simply replaces the suffix *.cpp by *.o for every file in the corresponding [directory]_SRCS file.  For example, in the file src/util/sources.mk, util_OBJS is defined by the pattern 
\code 
util_OBJS=$(util_SRCS:.cpp=.o)
\endcode
that simply replaces the file extension .cpp by .o in every path listed in the variable util_SRCS.

To add a source file to the makefile system, one must simply add the path to the source file in the sources.mk file in the directory that contains the new source file. The path to the each source file should be given as an absolute path in which the simpatico/src directory is represented using the variable $(SRC_DIR), as discussed in detail \ref make_paths "below". Adding the path to a source file to the [directory]_SRCS variable in the directory that contains the source file is enough to guarantee that it will be added to the corresponding variables in all parent directories, up to the namespace level directories.

The "all" target in each directory builds all of the object files listed in the [directory]_OBJS variable for that directory. Each file in that list is built using a pattern defined in the patterns.mk file of the associated namespace level directory. Entering "make all" from any directory at the namespace level or below will thus compile all of the object files in that directory and all of its subdirectories, and no others.

\section make_paths Source and Object File Paths

All file paths in sources.mk files are specified as absolute paths by using the makefile variable $(SRC_DIR) to represent the absolute path to the src/ directory, and adding the relative path from the src/ directory to source file of interest.  For example, the path to src/util/math/Vector.cpp is given in src/util/math/sources.mk as
\code

   $(SRC_DIR)/util/math/Vector.cpp

\endcode
The variable SRC_DIR must be set equal to the absolute path to the src/ directory in the file src/compiler.mk, which is then included in every other makefile. The correct value for this path should be set by the ./configure script during initial configuration. After substituting the value of $(SRC_DIR), every source file path in every sources.mk file expands to an absolute path.  

\section make_dependency Dependency Files

When automatic dependency generation is enabled, a dependency file will be generated for each source file. Each dependency file is generated as a side-effect of compilation, as dictated by the compilation patterns given in the namespace level patterns.mk files.  The dependency file associated with a source file has the same base name as the source file, with an extension *.d rather than *.cpp, and is placed in the same directory as the source and object files.

Each dependency file defines a makefile rule for the corresponding object (*.o) file target. The rule consists of the name of the object file target followed by a colon and list of files upon which it depends, of the form 
\code

class.o: class.cpp class.h header1.h header2.h ....

\endcode
Though not shown here, absolute paths are used for all files in real dependency files. The list of dependencies for each object (*.o) file target includes both the corresponding source (*.cpp) file and all of the header files that this source file directly or indirectly includes.  The makefile rule to construct an object file does not contain an explicit command to invoke the compiler, because the required command is given implicitly by a pattern rule defined in the namespace level patterns.mk file. 

In each makefile at the namespace level and below, a list of dependency files for individual *.o object files is included into the makefile by a command of the form
\code

-include $([directory]_OBJS:.o=.d)

\endcode
in which [directory] represents the mangled name of the directory containing the makefile. For example, in the file src/mcMd/mdSimulation, this line is
\code

-include $(mcMd_mdSimulation_OBJS:.o=.d)

\endcode
This line attempts to include a *.d dependency files for each *.o object file in the directory tree rooted at this directory.  Because each such dependency file contains a makefile rule for one object file target, this automatically generates a list of makefile rules for all object files in the tree rooted at this directory.  The dash in front of "include" instructs "make" to continue quietly if no dependency file is found for any of the object files listed in [directory]_OBJS variable. 

If automatic dependency generation has been enabled, dependency files are created as a side-effect of compilation, using the executable script bin/makeDep. The pattern rules defined in the namespace level patterns.mk files apply the makeDep script to a source file whenever that file is compiled, and thereby regenerate the associated dependency file.  The "makeDep" script works by calling the gnu g++ compiler with the -MM option to calculate dependencies, and then using a seperate python script to edit the resulting file by modifying the form of the paths for the target and dependency files. 

All paths in the dependency files are literal absolute paths. In the sources.mk files, absolute paths are expressed symbolically, by using $(SRC_DIR) to represent the src/ directory. Absolute paths must be expressed symbolically in the sources.mk files because these files are stored in the repository, and thus must express file paths in a portable form. Literal absolute paths may be used in dependency files because these files generated by the user as a side-effect of compilation, and thus need not be portable.

\section make_single How to compile a single source file

The most convenient way to compile a source file that you are working on is usually to just enter "make all" from the directory containing that source file and the associated header. If automatic dependency generation is enabled, and if you are working on only one class in that directory at a time, this will cause the make system to compile only the source file that you have modified.

Unfortunately, the build system conventions make it difficult to explictly compile only a single source file. The Simpatico makefile system uses absolute paths for all file paths. The "make" program is not smart enough to recognize the equivalence of absolute and relative paths.  As a result, the only way explicitly compile a single source file is to use the absolute path to the object file as a makefile target. For example, if the absolute path to the root simpatico directory within a user account named "george" was "/home/george/simpatico/", you (or George) could compile the source file src/mcMd/simulation/Simulation.cpp by entering
\code 
  make /home/george/simpatico/src/mcMd/simulation/Simulation.o
\endcode 
from either the src/mcMd/simulation or the src/mcMd/ directory.  The command "make Simulation.o", however, will not work. Most programmers find it too much of a nuisance to type absolute paths, which is why we recommend just using "make all" from the enclosing directory.

In order to use "make all" for development, however, you must comment out or remove unfinished or broken source files from the *_SRCS list in the sources.mk file, until you are ready to complete or fix them. Otherwise, entering "make all" will try to compile files that you know are not ready to be compiled.

<ul>
 <li> \ref developer_page  (Up)    </li>
 <li> \ref test_page       (Next)  </li>
</ul>

*/
}
