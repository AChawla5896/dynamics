namespace McMd
{

/*! \page potentials_page Potential Energy Classes

\section potentials_base_sec Base Classes
The mcSim and mdSim programs use the following set of base classes
for different types of potential energy:
<ul>
 <li> McMd::McPairPotential </li>
 <li> McMd::MdPairPotential </li>
 <li> McMd::BondPotential </li>
 <li> McMd::AnglePotential </li>
 <li> McMd::DihedralPotential </li>
 <li> McMd::ExternalPotential </li>
</ul>
Most of the names are self-explanatory: Bond, Angle, and Dihedral
potentials represent 2-body bond, 3-body angle, and 4-body 
dihedral covalent interactions.  An ExternalPotential represents 
a one-body potential in which the energy depends upon the position 
and type of a single atom. The McPairPotential and MdPairPotential
classes both represent nonbonded pair interactions, but define 
slightly different interfaces for MC and MD simulations. For all 
other potential energy types (i.e., for bond, angle, dihedral, 
and external potentials) a single base class is used in both MC 
and MD simulations.

The mdSim program uses an analogous set of base classes defined
in the DdMd namespace:
<ul>
 <li> DdMd::PairPotential </li>
 <li> DdMd::BondPotential </li>
 <li> DdMd::AnglePotential </li>
 <li> DdMd::DihedralPotential </li>
 <li> DdMd::ExternalPotential </li>
</ul>
with the same names as the corresponding McMd classes, but with
only one class for pair interactions.

All of the above potential energy base classes declare methods to 
calculate the contribution from a particular type of potential to 
the total energy and total stress or pressure of an associated 
system, as well as methods to calculate energies and forces 
arising from single groups of atoms, such as a single pair of 
nonbonded atoms.  All of the McMd potential classes except MdPairPotential
provide methods to calculate the corresponding energy contribution 
for a specific atom, for use in some MC move algorithms.  All of 
the DdMd potentials and all of the McMd potentials except MdPairPotential 
provide a method to calculate the forces exerted on all atoms in 
a System due to the associated type of potential (e.g., all 
nonbonded pair forces).

\section potentials_interaction_sec Interaction Classes and Potential Energy Class Templates

Subclassses of these potential energy base classes are actually
using a simpler set of "interaction" classes, which implement the
core calculations of energies and forces for small groups of 1, 2,
3 or 4 atoms. Each interaction classes represents a specific 
functional forms for the associated potential energy functions.
The interaction classes are simple, non-polymorphic classes, 
which provide non-virtual methods to calculate the energy and 
forces for a single group of interacting atoms, such as a single 
pair of nonbonded or bonded atoms, or the angle forces among a
group of three bonded atoms. For example, LJPair is a pair 
interaction class that represents the Lennard-Jones pair interaction,
while HarmonicBond is a bond interaction class that represents a 
harmonic bond potential.  Unlike the polymorphic potential energy 
classes, interaction classes do not provide methods to do 
calculations that involve, e.g., looping over all of the atoms 
or bonds of an associated system.

Subclasses of the potential energy base classes that represent
particular interactions are implemented by class templates. 
Each such class template takes an interaction class as a template
argument, and is derived from an associated potential class.
The name of each such class templates is given in all but a 
few cases by the name of the associated base class followed 
by the suffix "Impl" (for implementation). For example, the 
template that implements the BondPotential interface is called 
BondPotentialImpl. The template instantiation 
BondPotentialImpl<HarmonicBond> is a subclass of BondPotential 
that represents a harmonic bond potential.  The template 
BondPotentialImpl defines methods that implement a loop 
over all bonds in a system, as required to calculate the 
total bond energy of a System and to calculate bond forces 
for all atoms in a system, and that calls the methods of
the associated interaction class within that loop to calculate
forces and/or energies for individual bonds.  Analogous 
templates are provided for angle, dihedral, link and external 
forces. 

In the special case of non-bonded pair potentials, there are 
two different implementation templates, named McPairPotentialImpl 
and MdPairPotentialImpl, designed for MC and MD simulations, 
respectively. These use different algorithms to do the 
energy and force calculations required in MC and MD simulations,
and implement slightly different interfaces: The McPairPotentialImpl 
uses a cell list that is optimized for use in MC simulations. The
MdPairPotentialImpl uses a Verlet pair list to implement the force 
loop required in MD simulations.

\section potentials_factory_sec Factory Classes 

Simpatico provides a default factory class for each of the 
above types of potential energy. The BondFactory, AngleFactory, 
DihedralFactory, and ExternalFactory classes in the McMd 
namespace, and analogous classes with the same names in 
the DdMd namesapce, are derived from the Factory template, 
and use an interface similar to that of other factory 
classes.  Like other factory classes, they all provide 
a single factory() method that takes a string
argument and that (if possible) returns a pointer to a new 
instance of a subclass of the associated potential energy base 
class.  In all of the potential energy factory classes, the 
name string that is passed as an argument to the factory method 
is actually the name of the required interaction classes 
(which is also a name for the potential energy function).
For example, if the BondFactory::factory(std::string&) method 
is passed the string "HarmonicBond", it constructs an instance 
of BondPotentialImpl<HarmonicBond>, and returns a "HarmonicBond* 
base class pointer to this new object.  

The McMd::PairFactory class is slightly different. This class
provides two methods, named mdFactory() and mcFactory(), that 
each take the name of a pair interaction, such as "LJPair",
and return a pointer to a new MdPairPotential or McPairPotential 
object that is constructed using the appropriate implementation 
template.  The signatures of these methods are:
\code
   McMd::McPairPotential* mcFactory(std::string className);
   McMd::MdPairPotential* mdFactory(std::string className);
\endcode
Because McMd::PairFactory does not implement the interface 
defined by the standard Factory template, it is not derived 
from the Factory template. PairFactory also provides a third 
factory method that takes an McPairPotential by reference 
and returns a pointer to a corresponding MdPairPotential. 
This method is required for hybrid MC simulations, in which 
short MD simulations are used as proposed MC moves, and is
used to construct an MdPairPotential for use in MD simulation
that implements the same pair interaction as the McPairPotential 
used by the parent MC simulation. 

The implementations of the potential energy factory classes 
are generally very similar to those of other factory classes. 
Developers should consult the implementations of the 
default factory classes for different types of potential 
in the src/mcMd/potential/ and/or src/ddMd/potentials/ 
directories for further guidance. 

<ul>
 <li> \ref factory_page   (Previous)  </li>
 <li> \ref extend_page    (Up)        </li>
 <li> \ref subfactory_page    (Next)      </li>
</ul>
 
*/
}
