namespace McMd
{

/*! \page param_page Parameter File

All of the Simpatico programs use parameter files with a heirarchical file format. Each parameter file contains a set of nested blocks that begin and end with matched curly brackets, like blocks in a C program.  As an example, here is a complete parameter file for a simple constant energy (NVE) MD simulation, for use with the default version of mdSim.
\code
MdSimulation{
  FileMaster{
    commandFileName               commands
    inputPrefix                        in/
    outputPrefix                      out/
  }
  nAtomType                              2
  nBondType                              1
  atomTypes                              A   1.000
                                         B   1.000
  maskedPairPolicy              MaskBonded
  SpeciesManager{

    Homopolymer{
      moleculeCapacity                     100
      nAtom                                  8
      atomType                               0
      bondType                               0
    }

  }
  Random{
    seed                          -10742892
  }
  MdSystem{
    pairStyle                        LJPair
    bondStyle                  HarmonicBond 
    MdPairPotential{
      epsilon               1.000000000000e+00  1.000000000000e+00
                            1.000000000000e+00  1.000000000000e+00
      sigma                 1.000000000000e+00  1.000000000000e+00
                            1.000000000000e+00  1.000000000000e+00
      cutoff                1.122460000000e+00  1.122460000000e+00
                            1.122460000000e+00  1.122460000000e+00
      maxBoundary           cubic       12.000   
      PairList{
        atomCapacity                        1000
        pairCapacity                       10000
        skin                  2.500000000000e-01
      }
    }
    BondPotential{
      kappa                 2.000000000000e+03
      length                1.000000000000e+00
    }
    EnergyEnsemble{
      type                        adiabatic
    }
    BoundaryEnsemble{
      type                            rigid
    }
    NveVvIntegrator{
       dt                   5.000000000000e-03
    }
  }
  DiagnosticManager{
    baseInterval                          10

    DumpConfig{
      interval                           100
      outputFileName                   dump/
    }

    MdEnergyOutput{
      interval                           100
      outputFileName                  energy
    }

  }

}
\endcode
A parameter file contains of a set of nested blocks. Each block may contain zero or more lines that give values for individual simulation parameters, and zero or more nested subblocks. The nesting of parameter blocks in this file format reflects the organization of C++ objects from which the simulation is construsted: All the C++ objects that must read parameters from file during initialization are organized into a hierarchy, or tree, in which each object can have one "parent" objects and zero or "child" objects, in addition to parameters. A "child" object is generallly either a member of the parent class, or a dynamically allocated object that the parent is responsible for creating and destroying. Each object in this hierarchy is responsible for reading the associated block in the parameter file, which contains all the parameters necessary to initialize the associated object, as well as any subblocks associated with child sub-objects.  The root node of this tree is the main simulation object, which is always an instance of McMd::McSimulation (for mcSim), McMd::MdSimulation (for ddSim) or DdMd::Simulation (for ddSim).

Each block in a parameter file begins with a line containing a class name, which is the class of the associated C++ object, followed by an opening brace ("{"). No white space may appear between the class name and the opening brace.  For example, the block that initializes the "MdSystem" object in the above example begins with the line "MdSystem{".  Each block ends with a line containing only a matched closing brace (i.e., "}").  By convention, nested blocks are indented, but indentation and other additional white space is ignored when the file is parsed.  The main block, which contains all the others, is associated with the main simulation object.

Each block may also contain lines that contain values of individual parameters. The value of each parameter that is represented by a primitive C++ variable (e.g., an int, double, or bool) or by a std::string is given on a single line that contains a label string followed by a parameter value. Each parameter is associated with a member variable of the enclosing class. By convention, each parameter label is the same as the name of the associated class member variable, except that the parameter labels does not contain the trailing underscore that is used in the Simpatico source code to mark names of private class member variables.  For example, the number of atom types in an MdSimulation is given by private member variable named nAtomType_, which is indicated in the parameter file by a label "nAtomType".  Label names (like C++ variable names) may not contain white space.  

Some lines contain values for parameters that are defined in the source code as instances of non-primitive data types, such as classes or enumerations.  As for primitive variables, such varibles are contained on a single line containing a label followed by a text representation of the variable value.  In these cases, the text representation of the "value" of the variable must be defined by iostream extractor (>>) and insertor (<<) operators that have been defined for that data type.  For example, in the above file, the "type" member of the EnergyEnsemble object is an instance of the enumeration EnergyEnsemble::Type, which can take on values ADIABATIC (constant energy) or ISOTHERMAL (constant temperature).  The value of this variable is read by an overloaded extractor (>>) operator for this enum that recognizes either "adiabatic" or "ADIABATIC" as a valid string representation of one of the allowed enum values.

A sequence of lines in which a label appears only on the first line can represent the contents of a variable that represents a one one-dimensional array. In the format for an array, the first line the label (the name of the array) and the value of the first element, while subsequent lines contain values of subsequent elements.  Thus, for example, the atomTypes member of an MdSimulation is an array (a DArray < AtomType > container) that contains nAtomType instances of class AtomType. This array is input using a format in which the first line contains the label "atomTypes" (the name of the array), and in which this and each subsequent line contains a string representation of one AtomType object. The string representation of an AtomType, which is defined by the extractor (>>) operator for an AtomType, contains a name string ("A" or "B" in this example) followed by a floating point mass. (The mass is 1.0 for both of the types in this example). The number of elements in such an array (nAtomType in this example) must be known before the array is read. In this case, the number of elements in the atomTypes array is given by the value of "nAtomType", which is read before the "atomTypes" array.

Two-dimensional array and Matrix objects also use a multi-line format. In this case, the first line contains a label (the name of the associated matrix), followed by the elements of the first row, with subsequent rows on subsequent lines. In the above example, this format is used for the epsilon, sigma, and cutoff members of an LJPair pair potential object. Each of these parameters is represented internally as a two dimensional array, in which epsilon[i][j] is the value of the Lennard-Jones epsilon parameter for interactions between atoms of types i and j, for 0 < i, j <= nAtomType.

The meaning of most parameter labels should be self-explanatory. When they are not, the file format makes it easy to look up the meaning of the variable in the html documentation or source code: Each parameter in this file format is labelled by the name of a corresponding class member variable, and the name of the enclosing class is included in the file format.  The meaning of any parameter can thus be looked up by looking up that variable in the html documentation and/or *.h header file of the class named in the first line of the innermost enclosing parameter file block.

\section algorithm_section Parsing algorithm

In order to understand and use this file format, it helps to know a little about how it is parsed. As already noted, each block in a parameter file is associated with an object that is an instance of the class that is named in the opening line of the block.  Every class that reads data from the parameter file derived from abstract base class Util::ParamComposite, which declares a pure virtual method 
\code
Util::ParamComposite::readParam(std::istream&) = 0;
\endcode
that must be implemented by each subclass.  Each block in the file is parsed by the readParam method of the associated class. The opening line for an object of class Foo, which contains the string "Foo{", marks the spot at which the code enters the function Foo:readParam(), and the line containing the closing bracket "}" marks the point at which Foo::readParam() returns.  

The implementation of the readParam() method of a class defines the format of the associated parameter file block.  The readParam() method of each class must read whatever data is required to initialize an instance of that class. It must also invoke the readParam() method of each of its "child" objects, each of which is associated with a subblock in the parameter file.  Because readParam() is a class method, it can read values for private member variables, without exposing these variables outside the class. Each class is responsible for reading whatever data it needs from file in order to initialize its internal state, and for defining a file format for this data.  

The algorithm described above is an example of the so-called "Composite" programming pattern (http://en.wikipedia.org/wiki/Composite_pattern).  The most important virtues of this algorithm, in the present context, are that: (i) Because each class is responsible for reading its own parameters, it preserves modularity and encapsulation of private data, and (ii) it allows the file format to change almost automatically as the software evolves.  

The most reliable documentation of the file format for each parameter file block is the source code of the readParam() method of the class named in the opening line of the block.  An explanation of the programming conventions and methods used in all such readParam() methods is given \ref read_param_page "here". 

\section polymorphic_section Polymorphic Blocks

Some parameter file blocks are "polymorphic": A polymorphic block is one that is allowed to contain the file format appropriate for any of several possible subclasses of a polymorphic base class.  When a polymorphic block is encountered, the parent object must recognize what which subclass of the relevant base class is desired from the class name in the opening line of the block, and create and initialize an instance of the desired class.  

For example, in an mdSim simulation, the MdSystem object has an associated MdIntegrator object. The user may specify that this object should an instance of either NveVvIntegrator, a class that implements an energy conserving NVE velocity-Verlet integrator, or an instance of NvtNhIntegrator, an isothermal NVT Nose-Hoover integrator, among other choices. All of the available choices are subclasses of the abstract base class MdIntegrator. The parameter file block associated with the MdIntegrator object may contain the file format for any of the available subclasses of MdIntegrator.  If an NveVvIntegrator block is encountered, as in the above example file, the parent MdSystem will instantiae and initialize an NveVvIntegrator object, which will then be used in subsequent simulation.  To indicate that an NvtNhIntegrator was desired instead, this block in the parameter file could be changed to contain the file format for an NvtNhIntegrator, which would begin with the line "NvtNhIntegrator{".

Because different subclasses of MdIntegrator may require different parameters, each subclass defines its own parameter file format. For example, the format for a NvtNhIntegrator contains a parameter that controls the strength of the coupling of the system to a heat reservoir, which is not needed in an NveVvIntegrator, in addition to the step size parameter dt that is needed for either type of integrator. 

When the first line of a polymorphic block is encountered, the readParam() of the parent object must compare the subclass name that appears in the opening line to a list of known subclasses of the corresponding base class. In this example, it must recognize "NveVvIntegrator" as a valid name of a subclass of "MdIntegrator".  If it recognizes the subclass name, it creates a new instance of the desired subclass and then invokes the readParam method of this new instance to read the rest of the block.  The algorithm used to process polymorphic blocks is discussed in more detail \ref factory_page "here".

\section manager_section Manager Classes

The above example file contains blocks labelled "SpeciesManager" and "DiagnosticManager", which are example of Manager classes.  A Manager is a container that holds an array of pointers to dynamically allocated objects that are all instances of subclasses of specific base class. Thus, for example, a SpeciesManager hold an array  of Species* pointers to Species objects (i.e., instances of the Species base class or its subclasses) that represent different molecular species within a mixture. A DiagnosticManager contains an array of pointers to Diagnostic objects that will be used for data analysis and/or data output during a simulation. 

The parameter file block associated with a Manager class contains a sequence of subblocks, separated by spaces. Each of the subblocks is polymorphic: Each subblock may contain the file format for any known subclass of the associated base class. The readParam method of a Manager class is responsible for reading a sequence of such polymorphic subblocks, instantiating one object of the indicated subclass for each subblock, and appending a bas class pointer to each new object to an array of such pointers.  

\section potential_section Potential Energy Styles

In both MD and MC simulations, a System has several associated types of potential energy. By default, these include only a non-bonded pair potential and a bond potential. Other types of potential energy that are disabled by default, such as 3-body bond angle and 4-body dihedral potentials, may be enabled by setting associated flags in the file inter/defines.mk before compiling. 

For each type of potential energy, the parameter file format allows a user to choose from several forms for the potential energy function by specifying a "style" string parameter. For example, the type of nonbonded pair potential function is specified by the value of "pairStyle". This can take on values "LJPair", corresponding to a Lennard-Jones potential, or "DpdPair", corresponding to the soft potential typically used in dissipative particle dynamics (DPD) simulations. Each of the allowed values of this "style" string corresponds to the name of a class in the src/inter/pair directory that implements the core calculation of energy and/or force for a single pair of nonbonded atoms.  We will refer to the classes named by the pairStyle variable as pair "interaction" classes. Similarly, "bondStyle" can take on values "HarmonicBond" or "FeneBond", which are the names of bond interaction classes in src/inter/bond directory.  A parameter file for a code compiled with angle and dihedral potentials enabled would also contain "angleStyle" and "dihedralStyle" strings that specify choices of angle and dihedral interaction classes. 

These "style" variables are followed by a set of blocks that contain the parameters for different types of potential energy (pair, bond, etc.). In the above example, these blocks are labelled "MdPairPotential" and "BondPotential". Each of these blocks contains the set of parameters required by the interaction class (or functional form) specified by the corresponding "style" variable. These blocks are polymorphic only in the sense that that names of the required parameters depends on the choice of "style". In the above example, for which bondStyle == "HarmonicBond", the "MdBondPotential" block thus contains a spring constant "kappa" and a preferred bond length "length". If bondStyle were set to "FeneBond", this block would also contain a maximum bond length. The block of parameters required by a particular style is read by invoking the readParam method of an instance of the associated interaction class (e.g., "HarmonicBond"). 

The MdPairPotential parameter block contains not only the parameters required by the associated interaction (epsilon, sigma, and cutoff for the LJPair Lennard-Jones style), but also a parameter labelled maxBoundary and a PairList subblock. These additional parameters are required to create a Verlet pairlist, which is needed to efficiently compute pair interactions in an MD simulation. The classes MdPairPotential and MdBondPotential are abstract base classes that declare methods to calculate energies and forces for an entire System, as well as for individual pairs of atoms.  The corresponding classes 
McPairPotential and MdPairPotential for MC simulation also declare methods to calculate total pair or bond potential energies for a specified atom. The efficient treatment of pair interactions requires a pair list for MD simulations or cell list for MC simulations. The required data structures are private members of the subclasses of MdPairPotential and McPairPotential that implement these calculations. The 
parameters required to initialize these data structures are thus included within the MdPairPotential and McPairPotential parameter blocks, in addition to the potential energy parameters.

Note that the syntax used to specify a choice of interaction class is different from that used to specify choices of MdIntegrator, McMove or Diagnostic objects, all of which relied on the use of polymorhpic parameter blocks in which a subclass name is specified by the first name in the block.  The choice of interaction class (of functional form) for each potential energy is instead specified by the value of a "style" string variable.  This difference in syntax reflects a difference in design: The potential energy objects, such as the MdPairPotential, are actually implemented using templates, in which the value of the style variable is the name of an "interaction" class that is a template argument (see \ref McMd_NS_page).

<ul>
 <li> \ref usage_page   (Prev) </li>
 <li> \ref guide_page     (Up)   </li>
 <li> \ref commands_page  (Next) </li>
</ul>

*/

}
