/*
* Simpatico - Simulation Package for Polymeric and Molecular Liquids
*
* Copyright 2010, David Morse (morse@cems.umn.edu)
* Distributed under the terms of the GNU General Public License.
*/


This file documents programming and formatting conventions that should be used
in the source code of Simpatico:

--------------------------------------------------------------------------------
Low-level source Code Formatting:

1) Indent exactly 3 spaces per level. Do not use tabs for indentation.

2) For control structures (if, for, while, etc.), place the opening brace 
at the end of a line, and the closing brace on a line by itself, aligned 
with the beginning of the opening line, like this:
\code
   for (int i = 0; i < end; ++i) {
      doSomething();
   }
\endcode

3) For definitions of functions, classes, and namespaces, put the opening brace 
on a separate line, and align both opening and closing braces with the beginning 
of the function, class or namespace definition.

Example:
\code

namespace Util
{

   class SillyClass
   {
 
   public:

      int sillyMethod(int param1, int max);

   };


   inline int SillyClass::sillyMethod(int param1, int max)
   {
   
      int i;
      for (i = 0; i < max; ++i) {
         param1++;
      }
   
      if (param1 > 0) {
         return 0;
      } else {
         return 1;
      }
   
   }

}

\end

3) Wrap every source file in the src/ directory in a namespace block. Start 
the namespace declaration in the first column, with no preceding white space.  
The unit test framework in the in the tests/test directory is the only code
that is defined in the global namespace. 

4) In class definitions, align "public:", "protected:", and "private:" declarations 
with the beginning of the class definition statement, and with the opening and 
closing braces of the class definition. 

5) Use one space to separate keywords, parentheseses, and opening braces in 
conditional statements. Use one space after each semi-colon in for-loop 
statements, and one space after each comma in function parameter lists. Do 
not follow opening parentheses or precede closing parentheses by a space.
Do not add whitespace space before commas or semicolons.

6) Set off the operators  =, ==, <, >, +, and - by one space on either side. 
Multipication (*) and division (/) operators may or may not be set off by white
space. Exceptions can be made when saving a few spaces can avoid a line wrap. 

7) Break lines at 80 characters or less whenever possible, to preserve 
readability in printouts.

8) For one-line functions, the function definition may be defined on a single 
line after the line containing the function signature, like this:
\code
   inline int SillyClass::data() 
   {  return data_; }
\endcode

9) Consecutive function declarations or definitions within a file, with associated
documentation blocks, should be separated by only single blank line.

------------------------------------------------------------------------------
Class Definitions:

1) In class definitions, list public members first, then protected, then private.  
Within each block, list data members first, then methods.  

2) List any friend declarations at the end of a class definition in a 
"pseudo-block" that is preceded by a comment "//friends:" on a line by itself,
after the private members.  The "//friends:" comment should be aligned with 
the outer braces of the class definition. 

3) Inline method definitions should be given outside the class definition,
within the header file. The word "inline" should be added to the function 
definition, outside the class definition, but not to the function declaration.

Example (without dOxygen comment blocks):

\code
#ifndef DERIVED_H
#define DERIVED_H

namespace Util
{

   class Derived : public Base
   {
   
   public:
   
      int method1(int param1, double param2);

      const MyBuddy& myBuddy() const;

   protected:

      MyBuddy& myBuddy();

   private:
   
      int      data1_;
      MyBuddy* buddyPtr_;
   
   //friends:
   
      friend class MyBuddy;
   
   };

   // Inline methods

   inline const MyBuddy& Derived::buddy() const 
   {  return *buddyPtr_; }

   inline MyBuddy& Derived::buddy() 
   {  return *buddyPtr_; }

   inline int Derived::method1(int param 1, double param2) 
   {
      if (param1 == 0) {
         return data1_;
      } else 
      if (param2 > 0) {
         return int(param2);
      }
   }

}
#endif
\endcode

4) Declarations of class members (data or methods) and associated 
documentation comments within a class definition should be separated by 
a single blank line. 

5) Document every class definition and member function declarations with a 
doxygen documentation block.

------------------------------------------------------------------------------
Name Conventions:

1) All function and variable names are lower case camel, as in "myVariable" 
or "myData". 

2) Class, namespace, typedef, and enum names (i.e., all type names) are upper 
case camel, as in "MyClass" . 

3) Class member variable names other than static constants end with an 
underscore, like "data1_" and "data2_"  in the above example. All such member 
variables should be private or (occasionally) protected.

4) Static constant class member variable names are upper case camel, as in
"MaxDimension". These may be public.

5) Names of arrays and other containers use the plural form of an appropriate
name for an element. The name for an array of Atom objects might thus be 
"atoms", or "atoms_" if it is a class member. This convention is used for
both container classes and built-in C arrays.

6) Names of pointer variables end with a suffix Ptr.  A local Atom* pointer 
variable within a function might thus be called "atomPtr", while an Atom* 
class member might be called "atomPtr_". Use this convention only for 
pointers that are used to point to a single ojbect. Pointers that are 
intended to point to a dynamically allocated array should use the name 
convention (5) for an array (but use container objects in preference to
bare arrays).

7) Use the same parameter names in function definitions (global functions
or class methods) as those used in the corresponding declarations.

8) The name of a method  parameter that represents the value to which a 
class member variable should be set should be the member variable name, 
without the the trailing underscore.

9) Names of methods and other functions that are not simple accessors 
(discussed below) should usually be verbs. 

10) The name of a "setter" function that is passed a value for a corresponding 
member variable should begin with the prefix "set". The name of the value
should be the same as the name of member variable, without the underscore.
For example:

\code

   void Thing::setData(int data)
   {  data_ = data; }

\endcode
The same convention is used whether the value is passed by value, by const 
reference, or by non-constant references (which is necessary for methods that
store the address of the value). For example:
\code

    void Thing::setPosition(const Vector &position)
    {  position_ = position; }

    void Thing::setMolecule(Molecule &molecule)
    {  moleculePtr_ = &molecule; }

\endcode

11) The name of an accessor ("getter") functions whose only purpose to return 
a member variable by value or by reference should be the name of the member 
variable, without the trailing underscore. Simpatico thus does NOT use the 
common convention of appending a prefix "get" to the name of simple accessors. 
The same convention is used for accessors that return variables by value, 
by const reference, and by non-const reference. Such simple accessors should 
be inlined to avoid computational overhead. 

12) Avoid preprocessor macros, except for #include of header files and those 
used for conditional compilation (e.g., those used to distinguish debugging 
and production code).  All preprocessor macro names are upper case, with 
underscores between words.  No preprocessor macros other than include guards 
should be defined in header files, or in files that contain class templates. 

-------------------------------------------------------------------------------
Class and Function Interface Design Guidelines:

1) All nonstatic class member variables should be private or (very rarely)
protected.  Prefer private member variables over protected, and provide 
protected accessor and mutator functions as needed by derived classes.

2) Pass and return primitive data types by value, or pass values by non-const
reference when they must be modified within a function.

3) Do not pass objects (class instances) to functions by value. Whenever 
possible, pass objects by reference. Pass by const reference whenever 
possible. Pass by non-const reference only if the object will be modified 
inside the function (in-out or output parameters) or if a pointer to the 
object will be retained.

4) Prefer references over pointers as parameters in public function interfaces. 
Pass pointers to functions only if: i) a null value for the pointer is a 
meaningful possibility, or ii) the pointer contains an address that must be 
re-assigned within the function, in which case you must pass a pointer by 
reference.

5) Prefer references over pointers as function return values when a handle is 
required. Return pointers only if a null pointer is a meaningful possibility.  
The container classes all return objects by reference, and throw an Exception 
if, for example, a requested index is out of range. Accessor methods that 
return a handle to an object that is referenced by a pointer class member also 
return by reference, and can throw an Exception if the pointer is null. The 
Manager::factory(className& std::string) method returns by pointer, however, 
because a null pointer return value is used to indicate that the class name 
was not recognized.

6) Read-only access to a member variable of primitive type should be provided
(when needed) by an accessor that returns the member variable by value. 
Read-only access to a class instance, or to a pointer to a class instance, 
should usually be provided by a accessor method that returns the object by 
const reference. Both types of read-only accessor methods should be marked
const. 

7) Read-write access to a member variable of primitive type should be provided
(when needed) by defining both a mutator (a "set" function) and accessor that 
returns the member variable by value. 

8) Read-write access to a member object that is a class instance may be 
provided by a non-const accessor that returns a non-const reference. For example, 
if a class has an int member variable data_ and a member object_ that is an 
instance of class Object, you might consider providing any or (none) of the 
following accessor functions:

\code

   // Read access to a member of a primitive data type.
   int Thing::data() const
   {  return data_; }

   // Read access to a member object.
   const Object& Thing::object() const
   {  return object_; }

   // Read-write access to a member object.
   Object& Thing::&object_()
   {  return object_; }

\endcode

9) Write access to a class member that is a class instance may thus be 
provided either by providing an accessor that returns a non-const reference 
or by providing a set function that takes a const reference parameter.

Providing a set function should be preferred when one needs to enforce
checking of preconditions or to carry out operations necessary to 
maintain a consistent state for the object. For example, the function 
Boundary::setLength(const Vector& lengths) modifies the volume of a 
periodic simulation cell and other private variables that depend upon 
the lengths when the lengths Vector is modified, in addition to setting 
the elements of the lengths_ Vector member variable.

Providing an accessor function that returns a non-const reference to a 
member object is equivalent to making the member public, and so should 
be used only when this is what is desired. For example, the Atom and 
McSimulation classes provide the following methods:

\code

   McSystem& McSimulation::system() 
   {  return system_; }

   Vector& Atom::position() 
   {  return system_; }

\endcode

The advantages of this over providing a mixture of public and private members 
are that:

 - It avoids the need for users to remember which members we have chosen 
   to make public and which must be accessed through accessors.

 - It allows us to use a consistent naming scheme in which all member 
   variable names end with an underscore, without exposing the underscored 
   names outside the class implementation. 

 - It allows us to use the same syntax for accessing values that are 
   returned by value, const reference, or reference, while still allowing 
   fine control over the level of access.

 - It allows us to use the same syntax to access objects that are actually
   members of a class and those that are accessed through a pointer
   member.

-  It allows us to add (removable) sanity checks to accessor functions 
   for debugging, such as checks that pointers are not null in a function
   that returns objects that are accessed via pointers.

10) Avoid reference class members. Use pointer class members instead. We 
use references in the public interface of a class (function parameters and 
return values) but use pointers within the implementation (class members). 
Rational: The restrictions on references members in C++ are a nuisance and 
can cause confusing bugs. References members can only be initialized in the 
constructor initialization block, which is often not possible. A reference 
member of a class has an undefined value if the object to which it points 
is destroyed before its parent object.

11) Practice strict "const correctness".  Mark all function parameters and 
methods const that you can. If a class provides an accessor function that 
returns a non-const reference to a member, also provide a const accessor 
method that provides a const reference. Rational: This makes it possible
for const methods of other classes to have read-only access to members of
a class, and non-const methods to have read-write access.

12) Avoid dynamical allocation after program initialization, for reasons of
efficiency. In functions that may be invoked repeatedly during a simulation, 
avoid returning new objects that must be dynamically allocated within a
function. Instead, when necessary, return results as objects by modifying 
either an extra non-const reference output parameter or by modifying the 
object that invokes the method. (The latter convention is used in the Vector 
class). Both of these methods require that results be stored in an object 
that is provided by the invoking function.

-------------------------------------------------------------------------------
Data Structure Conventions:

1) Use the C++ iostream classes for all file IO. For consistency, avoid the 
C fscan() and fprint() methods. Use the wrapper classes in the src/format 
directory to simplify coding of formatted output to ostreams.

2) Use std::string to represent character strings whenever possible.

3) Use Util::Vector objects to represent Cartesian positions and separations, 
or any array of floating point numbers for which the number of elements equals 
the dimensionality of space (e.g., the dimensions of the Boundary for a
periodic orthorhombic unit cell). Use IntVector to represent corresponding
arrays of integers.

4) Prefer the container templates in src/util/containers over bare C arrays 
and STL containers. STL containers should be used when their is a need for 
their resizability or for other features not provided by the custom
containers. 

Rational: The preference for the custom containers is based on the fact that:
(1) They provide bound checking when NDEBUG is not defined, and (2) They do
not allow silently resized. The second property is important only for 
algorithms that use pointers to array elements, which could be invalidated
if the array is resized.

Use a DArray container (dynamically allocated array) as a replacement for 
1D dynamically allocated C array or std::vector, if a maximum dimension 
can be determined during initialization of a simulation. Use an FArray or 
SArray as replacement for static C array, to construct small arrays on the 
stack. Use an FArray when the exact number of dimensions is known at compile 
time, and an SArray when the maximum number of elements can be specified at
compile time, but the logical size of the array may be less than this
maximum. Use the corresponding DPArray and SPArray containers for arrays 
that only store pointers to objects, rather than actual objects. These can 
also be dereferenced and accessed by the array [] operator syntax, which 
always returns a reference to the associated object (not a pointer).

5) Use an RArray to create a local copy of the address of a DArray or a
bare C array, rather than a pointer or reference. An RArray holds a pointer 
to the underlying C array of the parent DArray and a copy of its capacity,
allowing bounds checking. The underlying C array is not destroyed by the
RArray destructor.

-------------------------------------------------------------------------------
Iterator conventions:

The code uses several types of container iterators, all of which follow the 
conventions described below. These conventions are slightly different from 
those of the C++ STL:

1) All iterators overload *, ->, and (prefix) ++ operators.  Iterator->member 
returns a member of that object, and ++Iterator increments the iterator.

2) Every iterator provides a bool method notEnd(), which should be used as 
the condition to terminate a loop. This returns false when the end of the 
container has already been passed by the previous increment operation.

3) Each container provides a method begin(Iterator& ) that takes the relevant
type of iterator as an argument, and that initializes the iterator to the 
first element in the container.  The standard form of a for-loop is thus:

Example:

\code

   Iterator iter;
   for (container.begin(iter); iter.notEnd(); ++i){
      // Do something with iter.
   }

\endcode

4) Typenames for some of most important iterators are defined by typedefs. The 
typedef McMd::System::MoleculeIterator is the type of iterator for all molecules 
of a specific Species within one System. The typedef McMd::Molecule::AtomIterator 
is the type for an iterator for all atoms within one molecule. The McMd::System 
class provides a method void begin(speciesId, iter) that initializes a 
System::MolecularIerator iterator iter for species number speciesId. 
The Molecule class provides a method void begin(iter) initializes a 
Molecule::AtomIterator. The syntax for a loop over all atoms in a System 
is thus:

\code
 
   System system;
   System::MoleculeIterator molIter:
   Molecule::AtomIterator   atomIter:

   // Loop over species
   for (int iSpecies = 0; iSpecies < nSpecies; ++iSpecies) {

      // Loop over molecules in species
      for (system.begin(species, molIter); !molIter.atEnd(); ++i){

         // Loop over atoms in one molecule
         for (molItr->begin(species, atomIter); !atomIter.atEnd(); ++atomIter){

            // Do something with atomIter

         }

      }

   }

\endcode

----------------------------------------------------------------------------
File Conventions

1) Header files names end with a suffix .h and source (implementation) files end with 
the suffix .cpp. Header (*.h) files are intended to be included by other files, 
whereas source (*.cpp) files are compiled separately and linked. 

2) Write one public class per file. The base name of the header and implementation 
files for a class (excluding the .h and .cpp suffixes) should be the class name, 
capitalized the same way as the class name.

3) Use header guards in all header files.

4) In header files, use forward class declarations rather than including class 
headers whenever possible. Headers are needed for base classes, member objects,
typdefs, templates, and base classes used in inline functions.  
  
5) With few exceptions, project header files that are required by a source file 
should be included explicitly, to document the dependency, even if they would 
be indirectly included via another included header file. Reliance on indirect
inclusion is fragile. Exceptions are: 

   a) A class MyClass.cpp implementation file may indirectly include any 
      header files that are included by the corresponding in MyClass.h.
   b) A derived class may indirectly include files from its base class.
   c) The Exception.h header is always included indirectly by including 
      the src/util/global.h file. 

6) Avoid "using" statements for namespaces in header files. Specifically, do 
not EVER use a "using std" statement to load the entire C++ standard library 
into a header file. 

7) Use explicitly qualified names, such as std::cin and std:: string, in 
function parameter lists, within both declarations and definitions. Do this 
even in *.cpp implementation files, because dOxygen gets confused if you use 
different conventions in the declaration and the definition of a function

----------------------------------------------------------------------------
Documentation Conventions (via dOxygen):

1) Use dOxygen documentation conventions to document all public and protected
named quantities, i.e., all classes, methods, member variables, namespaces, 
global functions, typedefs, enums, and constants. 

2) The documentation for every such named item should begin with a brief 
single-sentence synopsis, which ends with a period. For many items, this is 
all that is required. 

3) dOxygen documentation for a class method should be above the method
declaration within the class definition. This comment block should document 
everything a user of the method needs to know use it correctly, without 
having to read the function definition. This includes any necessary 
comments about preconditions (what must be true before this method can
be called), postconditions (what has changed to the state of the program
after the method returns).

4) Document all function parameters, using the dOxygen \param keyword.

5) Most class method declarations should be documented with a multi-line 
dOxygen block comment that begins with "/**" alone on a line (note the 
extra "*")  and ends with "*/" alone on a line.

Example:

\code

   /**
   * Align the universe. 
   *
   * This is a longer discussion of what the method does, and of how and
   * why it does it. It may also contain a discussion of assumptions, and
   * of the algorithm. 
   *
   * A longer discussion may contain two or more paragraphs, separated by
   * blank lines.
   *
   * \param thing1 value of some quantity
   * \param thing2 flag to determine what to do with thing1
   * \return shift in the position of the universe
   */
   double alignUniverse(double thing1, bool thing2);

\endcode

6) Private class member variables may be documented either using the long style 
used for functions or by using a single line dOxygen comment format that begins 
with "///" (note the extra backslash), as follows:

\code

   public:
   
      /**
      * Return data1.
      */
      int data1()
      { return data1; }
  
      // ...
 
   private:
   
      /// Value of very important thingy.
      int data1;

\endcode

7) Do not use a dOxygen comment format to document the definition of a method
outside of a class definition. Doxygen comments are used only for declarations.
Most function definitions are documented in the following format, with only a 
single * in the first line, so that the comment will not be parsed by dOxygen:

\code

   /* 
   * Brief reminder of purpose. Possibly comments on implementation.
   */
   void MyClass:myFunction(int param)
   {
       // Do something here
   }

\endcode

----------------------------------------------------------------------------
Error Handling and Debugging:

1) Include the file <util/global.h> in all files that use C assert() statements
or that can throw exceptions. This causes NDEBUG to be defined if UTIL_DEBUG is
defined, automatically includes the "Exception.h" and "Log.h" header files, and
defines the UTIL_THROW(..) macro that is used to throw exceptions.

2) For checks that are intended only for debugging, use c assert() statements 
or enclose the test in a #ifndef UTIL_DEBUG .... #endif block. Undefining the 
UTIL_DEBUG macro, which also causes NDEBUG to be defined, will then turn off
all such debugging tests. 

3) In both debugging and release code, throw Exception objects for all errors 
except those caught by C assert() statements.  Use the UTIL_THROW macro defined
in src/util/global.h to throw Exceptions. This macro prints a message and the 
file and line number from which an Exception is thrown to aid debugging.

4) Use user-defined Exceptions only for real errors, and not for control flow. 
Such erros should always cause the program to terminate, which is the default 
behavior. Catch and rethrow exceptions only if doing so makes it possible for
the program to terminate more gracefully, or to provide more information for 
debugging.
