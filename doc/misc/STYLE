/*
* Simpatico - Simulation Package for Polymeric and Molecular Liquids
*
* Copyright 2010, David Morse (morse@cems.umn.edu)
* Distributed under the terms of the GNU General Public License.
*/


This file documents programming and formatting conventions that should be used
in the source code of Simpatico:

--------------------------------------------------------------------------------
Source Code Formatting:

1) Indent 3 spaces per level. Do not use tabs for indentation.

2) Break lines at 80 characters or less, to preserve readability in printouts.

3) Set off binary operators (e.g., =, ==, <, >, etc.) by one space on either
side. Exceptions can be made when saving a few spaces can avoid a line wrap. 

4) Use one space to separate keywords, parentheseses, and opening braces in 
conditional statements. Use one space after each semi-colon in for-loop 
statements, and one space after each comma in function parameter lists. Do 
not follow opening parentheses or precede closing parentheses by a space.
Do not add whitespace space before commas or semicolons.

5) Use Kernigan and Richie (K&R) style for opening and closing braces. 
For control structures (if, for, while, etc.), place the opening brace at 
the end of a line, and the closing brace on a line by itself, aligned with
the beginning of the opening line. For definitions of functions and classes,
however, put the opening brace on a separate line, and align both opening
and closing braces with the beginning of the function or class definition.
Also put the opening brace on a separate line for namespace blocks.

Example:
\code

namespace Util
{

   class SillyClass
   {
 
   public:

      int sillyMethod(int param1, int max);

   };


   inline int SillyClass::sillyMethod(int param1, int max)
   {
   
      int i;
      for (i = 0; i < max; ++i) {
         param1++;
      }
   
      if (param1 > 0) {
         return 0;
      } else {
         return 1;
      }
   
   }

}

\end

6) Wrap every source file in a namespace block. Start the namespace
declaration in the first column, with no preceding white space.  All 
source code in Simpatico is defined within one of several namespaces 
(Util, McMd, and DdMd).  The only exception is the unit test framework 
in directory src/test, which is not intended to be included in the 
source code, and so is defined in the global namespace.

Example:
\code
namespace Util
{
 
   int myFunction(int param1, int power) 
   {
      int output = 1;
      for (int i = 0; i < counter; ++i) {
         output *= param1;
      }
      return output;
   }

}
\endcode

7) For one-line functions, the function body may instead be defined on a 
single line after the line containing the function signature. The opening 
brace should be aligned with the beginning of the function signature, with 
the closing brace at the end of the line:

\code
   inline int data() 
   {  return data_; }
\endcode

8) Consecutive function definitions and associated documentation blocks
within a file should be separated by a single blank line. This applies 
to both global functions and class method definitions.

------------------------------------------------------------------------------
Class Definitions:

1) In class definitions, list public members first, then protected, then 
private.  Within each block, list data members first, then methods.  Align 
"public:", "protected:", and "private:" declarations with the beginning of
the class definition statement, and with the opening and closing braces of 
the class definition. 

2) List any friend declarations at the end of a class definition in a 
"pseudo-block" that is preceded by a comment "//friends:" on a line by itself,
after the private members.  The "//friends:" comment should be aligned with 
the "public", "protected:" and "private:" declarations, and with the outer 
braces of the class definition. 

3) Inline method definitions should be given outside the class definition,
within the header file. The word "inline" should be added to the function 
definition, outside the class definition, but not to the function declaration.


Example (without dOxygen comment blocks):

\code
#ifndef DERIVED_H
#define DERIVED_H

namespace Util
{

   class Derived : public Base
   {
   
   public:
   
      int method1(int param1, double param2);

      const MyBuddy& myBuddy() const;

   protected:

      MyBuddy& myBuddy();

   private:
   
      int      data1_;
      MyBuddy* buddyPtr_;
   
   //friends:
   
      friend class MyBuddy;
   
   };

   // Inline methods

   inline const MyBuddy& Derived::buddy() const 
   {  return *buddyPtr_; }

   inline MyBuddy& Derived::buddy() 
   {  return *buddyPtr_; }

   inline int Derived::method1(int param 1, double param2) 
   {
      if (param1 == 0) {
         return data1_;
      } else 
      if (param2 > 0) {
         return int(param2);
      }
   }

}
#endif
\endcode

4) Declarations of class members (data or methods) and associated 
documentation comments within a class definition should be separated by 
a single blank line. Real code should contain doxygen documentation for
all class members, though the above examples do not. 

------------------------------------------------------------------------------
Name Conventions:

1) All function and variable names are lower case camel, as in "myVariable" 
or "myData". 

2) Class, namespace, typedef, and enum names (i.e., all type names) are upper 
case camel, as in "MyClass" . 

3) Class member variable names other than static constants end with an 
underscore, like "data1_" and "data2_"  in the above example. All such member 
variables should be private or (occasionally) protected.

4) Static constant class member variable names are upper case camel, as in
"MaxDimension". These may be public.

5) Names of arrays and other containers use the plural form of an appropriate
name for an element. The name for an array of Atom objects might thus be 
"atoms", or "atoms_" if it is a class member. This convention is used for
both container classes and built-in C arrays.

6) Names of pointer variables end with a suffix Ptr.  A local Atom* pointer 
variable within a function might thus be called "atomPtr", while an Atom* 
class member might be called "atomPtr_". Use this convention only for 
pointers that are used to point to a single ojbect. Pointers that are 
intended to point to a dynamically allocated array should use the name 
convention (5) for an array (but use container objects in preference to
bare arrays).

7) Use the same parameter names in function definitions (global functions
or class methods) as those used in the corresponding declarations.

8) The name of a method  parameter that represents the value to which a 
class member variable should be set should be the member variable name, 
without the the trailing underscore.

9) Names of methods and other functions that are not simple accessors 
(discussed below) should be verbs. 

10) The name of a "setter" function that is passed a value for a corresponding 
member variable should begin with the prefix "set". For example:

\code

   void Thing::setData(int data)
   { data_ = data; }

\endcode

The same convention is used for methods that are passed an object by value 
or constant reference and copy its value into a member variable, or that are 
passed a non-const reference and that store the address of the object in a 
member variable. For example:

\code

    void Thing::setPosition(const Vector &position)
    { position_ = position; }

    void Thing::setMolecule(Molecule &molecule)
    { moleculePtr_ = &molecule; }

\endcode

11) The name of an accessor ("getter") functions whose only purpose to return 
a member variable by value or by reference should be the name of the member 
variable, without the trailing underscore. Simpatico thus does NOT use the 
common convention of appending a prefix "get" to the name of simple accessors. 
The same convention is used for accessors that return variables by value, 
by const reference, and by non-const reference. Such simple accessors should 
be inlined to avoid computational overhead. 

12) Avoid preprocessor macros, except for #include of header files and those 
used for conditional compilation (e.g., those used to distinguish debugging 
and production code).  All preprocessor macro names are upper case, with 
underscores between words.  Macros that are used in the util directory should 
be defined in src/util/config.h, and should be given names that begin with 
UTIL_. No preprocessor macros (other than include guards) should be defined 
in header files, or in files that contain class templates. 

-------------------------------------------------------------------------------
Class and Function Interface Design Guidelines:

1) All nonstatic class member variables should be private or (very rarely)
protected.  Prefer private member variables over protected, and provide 
protected accessor and mutator functions as needed by derived classes.

2) Pass and return primitive data types by value, or pass values by non-const
reference when they must be modified within a function.

3) Do not pass objects (class instances) to functions by value. Whenever 
possible, pass objects by reference. Pass by const reference whenever 
possible. Pass by non-const reference only if the object will be modified 
inside the function (in-out or output parameters) or if a pointer to the 
object will be retained.

4) Prefer references over pointers as parameters in public function interfaces. 
Pass pointers to functions only if: i) a null value for the pointer is a 
meaningful possibility, or ii) the pointer contains an address that must be 
re-assigned within the function, in which case you must pass a pointer by 
reference.

5) Prefer references over pointers as function return values when a handle is 
required. Return pointers only if a null pointer is a meaningful possibility.  
The container classes all return objects by reference, and throw an Exception 
if, for example, a requested index is out of range. Accessor methods that 
return a handle to an object that is referenced by a pointer class member also 
return by reference, and can throw an Exception if the pointer is null. The 
Manager::factory(className& std::string) method returns by pointer, however, 
because a null pointer return value is used to indicate that the class name 
was not recognized.

6) Read-only access to a member variable of primitive type should be provided
(when needed) by an accessor that returns the member variable by value. 
Read-only access to a class instance, or to a pointer to a class instance, 
should usually be provided by a accessor method that returns the object by 
const reference. Both types of read-only accessor methods should be marked
const. 

7) Read-write access to a member variable of primitive type should be provided
(when needed) by defining both a mutator (a "set" function) and accessor that 
returns the member variable by value. 

8) Read-write access to a member object that is a class instance may be 
provided by a non-const accessor that returns a non-const reference. For example, 
if a class has an int member variable data_ and a member object_ that is an 
instance of class Object, you might consider providing any or (none) of the 
following accessor functions:

\code

   // Read access to a member of a primitive data type.
   int Thing::data() const
   { return data_; }

   // Read access to a member object.
   const Object& Thing::object() const
   { return object_; }

   // Read-write access to a member object.
   Object& Thing::&object_()
   { return object_; }

\endcode

9) Write access to a class member that is a class instance may thus be 
provided either by providing an accessor that returns a non-const reference 
or by providing a set function that takes a const reference parameter.

Providing a set function should be preferred when one needs to enforce
checking of preconditions or to carry out operations necessary to 
maintain a consistent state for the object. For example, the function 
Boundary::setLength(const Vector& lengths) modifies the volume of a 
periodic simulation cell and other private variables that depend upon 
the lengths when the lengths Vector is modified, in addition to setting 
the elements of the lengths_ Vector member variable.

Providing an accessor function that returns a non-const reference to a 
member object is equivalent to making the member public, and so should 
be used only when this is what is desired. For example, the Atom and 
McSimulation classes provide the following methods:

\code

   McSystem& McSimulation::system() 
   {  return system_; }

   Vector& Atom::position() 
   {  return system_; }

\endcode

The advantages of this over providing a mixture of public and private members 
are that:

 - It avoids the need for users to remember which members we have chosen 
   to make public and which must be accessed through accessors.

 - It allows us to use a consistent naming scheme in which all member 
   variable names end with an underscore, without exposing the underscored 
   names outside the class implementation. 

 - It allows us to use the same syntax for accessing values that are 
   returned by value, const reference, or reference, while still allowing 
   fine control over the level of access.

 - It allows us to use the same syntax to access objects that are actually
   members of a class and those that are accessed through a pointer
   member.

-  It allows us to add (removable) sanity checks to accessor functions 
   for debugging, such as checks that pointers are not null in a function
   that returns objects that are accessed via pointers.

10) Avoid reference class members. Use pointer class members instead. We 
use references in the public interface of a class (function parameters and 
return values) but use pointers within the implementation (class members). 
Rational: The restrictions on references members in C++ are a nuisance and 
can cause confusing bugs. References members can only be initialized in the 
constructor initialization block, which is often not possible. A reference 
member of a class has an undefined value if the object to which it points 
is destroyed before its parent object.

11) Practice strict "const correctness".  Mark all function parameters and 
methods const that you can. If a class provides an accessor function that 
returns a non-const reference to a member, also provide a const accessor 
method that provides a const reference. Rational: This makes it possible
for const methods of other classes to have read-only access to members of
a class, and non-const methods to have read-write access.

12) Avoid dynamical allocation after program initialization, for reasons of
efficiency. In functions that may be invoked repeatedly during a simulation, 
avoid returning new objects that must be dynamically allocated within a
function. Instead, when necessary, return results as objects by modifying 
either an extra non-const reference output parameter or by modifying the 
object that invokes the method. (The latter convention is used in the Vector 
class). Both of these methods require that results be stored in an object 
that is provided by the invoking function.

-------------------------------------------------------------------------------
Data Structure Conventions:

1) Use the C++ iostream classes for all file IO. For consistency, avoid the 
C fscan() and fprint() methods. Use the wrapper classes in the src/format 
directory to simplify coding of formatted output to ostreams.

2) Use std::string to represent all character strings. 

3) Use Util::Vector objects to represent Cartesian positions and separations, 
or any array of floating point numbers for which the number of elements equals 
the dimensionality of space (e.g., the dimensions of the Boundary for a
periodic orthorhombic unit cell). Use IntVector to represent corresponding
arrays of integers.

4) Prefer the container objects in src/util/containers over bare C arrays 
and STL containers. STL containers should be used when their is a need for 
their resizability or for other features not provided by the custom
containers. The preference for the custom containers is based on the fact
that they provide bound checking when NDEBUG is not defined. Use a DArray 
container (dynamically allocated array) as a replacement for 1D dynamically 
allocated C arrays or std::vector, if a maximum dimension can be determined 
during initialization of a simulation. Use an FArray or an SArray as 
replacement for static C array, to construct small arrays on the stack. Use
an FArray when the exact number of dimensions is known at compile time,
and an SArray when the maximum number of elements can be specified at
compile time, but the logical size of the array may be less than this
maximum.  Use the corresponding DPArray and SPArray containers for arrays 
that only store pointers to objects, rather than actual objects. These can 
also be dereferenced and accessed by the array [] operator syntax, which 
always returns a reference to the associated object (not a pointer).

5) Use an RArray to create a local copy of the address of a DArray or a
bare C array, rather than a pointer or reference. An RArray holds a pointer 
to the underlying C array of the parent DArray and a copy of its capacity,
allowing bounds checking. The underlying C array is not destroyed by the
RArray destructor.

-------------------------------------------------------------------------------
Iterator conventions:

The code uses several types of container iterators, all of which follow the 
conventions described below. These conventions are slightly different from 
those of the C++ STL:

1) All iterators overload *, ->, and (prefix) ++ operators. The bidirectional 
ListIterator also overload (prefix) --. *Iterator returns the object to which
the iterator points. Iterator->member returns a member of that object, and
++Iterator increments the iterator.

2) Every iterator provides a bool method atEnd(). This returns true when the 
end of the container has already been passed by the previous increment or 
(for a bidirectional iterator) decrement operation.

3) Each container may be accessed by a forward iterator that is initialized by 
a method void begin(Iterator&) method that initializes the relevant type of 
iterator. The standard form of a for-loop is thus:

Example:

\code

   Iterator iter;
   for (container.begin(iter); !iter.atEnd(); ++i){
      // Do something with iter.
   }

\endcode

4) Typenames for the most important iterators are defined by typedefs. The 
typedef System::MoleculeIterator is the type of iterator for all molecules of 
a specific Species within one System. The typedef Molecule::AtomIterator is 
the type for an iterator for all atoms within one molecule. The System class 
provides a method void begin(speciesId, iter) that initializes a 
System::MolecularIerator iterator iter for species number speciesId. 
The Molecule class provides a method void begin(iter) initializes a 
Molecule::AtomIterator. The syntax for a loop over all atoms in a System 
is thus:

\code
 
   System system;
   System::MoleculeIterator molIter:
   Molecule::AtomIterator   atomIter:

   // Loop over species
   for (int iSpecies = 0; iSpecies < nSpecies; ++iSpecies) {

      // Loop over molecules in species
      for (system.begin(species, molIter); !molIter.atEnd(); ++i){

         // Loop over atoms in one molecule
         for (molItr->begin(species, atomIter); !atomIter.atEnd(); ++atomIter){

            // Do something with atomIter

         }

      }

   }

\endcode

----------------------------------------------------------------------------
File Conventions

1) Header files names end with .h and implementation files end with the suffix 
.cpp. Header (*.h) files are intended to be included by other files, whereas 
implementation (*.cpp) files are compiled separately and linked. 

2) Write one public class per file. The base name of the header and implementation 
files for a class (excluding the .h and .cpp suffixes) should be the class name, 
capitalized the same way as the class name.

3) Use header guards in all header and source files.

4) In header files, use forward class declarations rather than including class 
headers whenever possible. Headers are needed for base classes, member objects,
typdefs, templates, and base classes used in inline functions.  
  
5) With few exceptions, project header files that are required by a source file 
should be included explicitly, to document the dependency, even if they would 
be indirectly included via another included header file. Exceptions are: 

   a) A class MyClass.cpp implementation file may indirectly include any 
      header files that are included by the corresponding in MyClass.h.
   b) A derived class may indirectly include files from its base class.
   c) The Exception.h header is always included indirectly by including 
      the src/util/global.h file. 

6) Standard C and C++ header files may be included indirectly when it is not 
felt that this will not cause confusion. For example, <iostream> will be 
included in the header file of any class derived ParamComponent, or from its 
subclass ParamComposite, and so does not need to be directly included. 

7) Avoid "using" statements in header files. Specifically, do not ever use a 
"using std" statement to load the entire C++ standard library into a header 
file. Instead use explicitly qualified names, such as std::istream, std::cin, 
std::string within header files. 

8) Use explicitly qualified names, such as std::cin and std:: string, in 
function parameter lists, within both declarations and definitions. Do this 
even in *.cpp implementation files, because dOxygen gets confused if you use 
different conventions in the declaration and the definition of a function

9) Each *.cpp implementation file must have a *.o target in the Makefile. 
Header *.h files for which there is no corresponding *.cpp file may also 
have targets in the Makefile, but these are used only for debugging, and 
are not compiled as part of the "make all" target.

----------------------------------------------------------------------------
Documentation Conventions (via dOxygen):

1) Use dOxygen documentation conventions to document all public and protected
named quantities, i.e., all classes, methods, member variables, namespaces, 
global functions, typedefs, enums, and constants. 

2) The documentation for every such named item should begin with a brief 
single-sentence synopsis, which ends with a period. For many items, this 
is all that is required. 

3) dOxygen documentation for a class method should be above the method
declaration within the class definition. This comment block should document 
everything a user of the method needs to know use it correctly, without 
having to read the function definition. This includes any necessary 
comments about preconditions (what must be true before this method can
be called), postconditions (what has changed to the state of the program
after the method returns).

4) Document all function parameters, using the dOxygen \param keyword.

5) Most class method declarations should be documented with a multi-line 
dOxygen block comment that begins with "/**" alone on a line (note the 
extra "*")  and ends with "*/" alone on a line.

Example:

\code

   /**
   * Align the universe. 
   *
   * This is a longer discussion of what the method does, and of how and
   * why it does it. It may also contain a discussion of assumptions, and
   * of the algorithm. 
   *
   * A longer discussion may contain two or more paragraphs, separated by
   * blank lines.
   *
   * \param thing1 value of some quantity
   * \param thing2 flag to determine what to do with thing1
   * \return shift in the position of the universe
   */
   double alignUniverse(double thing1, bool thing2);

\endcode

6) Class member variables may be documented either using the long style used
for functions or by using a single line dOxygen comment format that begins with 
"///" (note the extra backslash), as follows:

\code

   public:
   
      /**
      * Return data1.
      */
      int data1()
      { return data1; }
  
      // ...
 
   private:
   
      /// Value of very important thingy.
      int data1;

\endcode

7) Do not use a dOxygen comment format to document the definition of a method
outside of a class definition. Most function definitions are documented in the 
following format, with only a single * in the first line, so that the comment 
will not be parsed by dOxygen:

\code

   /* 
   * Brief reminder of purpose. Possibly comments on implementation.
   */
   void MyClass:myFunction(int param)
   {
       // Do something here
   }

\endcode

----------------------------------------------------------------------------
Error Handling and Debugging:

1) Include the file <util/global.h> in all files that use C assert() statements
or that can throw exceptions. This causes NDEBUG to be defined if UTIL_DEBUG is
defined, automatically includes the "Exception.h" and "Log.h" header files, and
defines the UTIL_THROW(..) macro that is used to throw exceptions.

2) For checks that are intended only for debugging, use c assert() statements 
or enclose the test in a #ifndef UTIL_DEBUG .... #endif block. Undefining the 
UTIL_DEBUG macro, which also causes NDEBUG to be defined, will then turn off
all such debugging tests. 

3) In both debugging and release code, throw Exception objects for all errors 
except those caught by C assert() statements.  Use the UTIL_THROW macro defined
in src/util/global.h to throw Exceptions. This macro prints a message and the 
file and line number from which an Exception is thrown to aid debugging.

4) Use user-defined Exceptions only for real errors, and not for control flow. 
Such erros should always cause the program to terminate, which is the default 
behavior. Catch and rethrow exceptions only if doing so makes it possible for
the program to terminate more gracefully, or to provide more information for 
debugging.
