------------------------------------------------------------------------
Util::Boundary

     1) Add method shiftGen(Vector&) and shiftGen(Vector& , intVector&)
       to shift generalized coordinate vectors.

------------------------------------------------------------------------
DdMd::Domain:

     if (UTIL_ORTHOGONAL) {
        1) Change domainBound to return generalized coordinates.
        2) Change ownerRank(Vector& ) to use generalized coordinates
        3) Change isInDomain(Vector& ) to use generalized coordinates.

        In each method, change line defining dL to following:

        if (UTIL_ORTHOGONAL) {
           dL = boundaryPtr_->length(i) / double(gridDimensions_[i]);
        } else {
           dL = 1.0 / double(gridDimensions_[i]);
        }
     }

     4) Update unit tests and test

     5) IF we move to consistent use of generalized coordinates in Domain,
        then remove boundaryPtr_ (Used only in above functions)

------------------------------------------------------------------------
DdMd::AtomStorage

     1) Add methods

     void transformCartToGen(const Boundary& boundary);
     void transformGenToCart(const Boundary& boundary);

     2) Add bool member and accessor to mark state and method 
  
     bool isCartesian() const;
     bool isCartesion_;

     3) In initializer list of constructor:

        #ifdef UTIL_ORTHOGONAL 
        isCartesian_ = false,
        #else
        isCartesian_ = true,
        #endif

        Can be changed only by transform and clear methods.

     3) Add method clear(). Should clear all atoms and ghosts, and set
     isCartesian_ to its initial value. 

------------------------------------------------------------------------
DdMd::Distributor

     #ifdef (UTIL_ORTHOGONAL) -> use generalized coordinates throughout.
     Change addAtom to use generalized coordinates
   
     #ifdef (UTIL_ORTHOGONAL) { 
        1) In addAtom, call shiftGen rather than Shift.
        2) Call of domainPtr_->ownerRank unchanged.
     }
     #endif
------------------------------------------------------------------------
DdMd::ConfigIo

     Policies / Decisions:

     1) Coordinates in file will be Cartesian
        Motivation: Allows format more similiar to single processor codes.

     2) Atom coordinates will be generalized upon exit from readConfigIo.
        Motivation: Allows a CelList to be built immediately after reading.
                    Leaves coordinates in form used internally
                    Delay transformation to Cartesian until needed.

     3) Coordinates will be Cartesian throughout writeConfigIo.
        Motivation: Coordinates will be Cartesian throughout most time steps.
                    Cartesian coordinates are needed in output file.

     Changes, in readConfig:

     1) Clear AtomStorage before reading
     2) If (!UTIL_ORTHOGONAL) transform each position to generalized 
        coordinates immediately after reading.

------------------------------------------------------------------------
DdMd::Exchanger:

     if (UTIL_ORTHOGONAL) use generalized coordinates throughout:

     1) Within loop over i to define limiting coordinate values:
        Define local variable  length = boundary.length()[i];
        Define local variable  cut = cutoff_/length
        Define inner_ and outer_ as bound +- cut
    
     2) In exchangeAtoms, exchangeGhosts, update, wherever particle 
        positions are shifted, if (!UTIL_ORTHOGONAL) use generalized 
        coordinate shift. In each of these methods:

        a) Outside loop over i and j, add variable declaration:

        double rshift;

        b) Within each loop over i, j, inside the j loop, define:

        if (UTIL_ORTHOGONAL) {
           rshift = shift*boundaryPtr_->lengths()[i];
        } else {
           rshift = 1.0;
        }

        c) Change shift execution for each atom:

        if (shift) {
           coordinate += rshift 
        }

     3) Update ExchangerTest and retest.

        Tests should also have if (UTIL_ORTHOGONAL) { ... } blocks so 
        that they work correctly in either mode.

------------------------------------------------------------------------
DdMd::Collector

     Algorithm to be completely unchanged: All particles are sent to
     the master processor without using information about positions.

------------------------------------------------------------------------
CellList:

     if (UTIL_ORTHOGONAL) use generalized coordinates throughout:

     1) Define allocate and makeGrid methods that takes a Vector of 
     cutoff lengths. Each should be defined externally as a ratio
     cutoff_/boundary.length()[i] for generalized coordinates or
     cutoff_ for Cartesian coordinates.

     2) If we later decide on consistent use of generalized coordinates, 
     remove boundaryPtr_ (it will have become unnecessary).

------------------------------------------------------------------------
PairPotential:

     1) Separate buildCellList and buildPairList methods.

     2) If (UTIL_ORTHOGONAL) use generalized coordinates throughout 
     buildCellList and Cartesian throughout buildPairList.

------------------------------------------------------------------------
Integrators:

     1) Invoke methods to transform atomic coordinate systems.
     2) Call buildCellList and buildPairList separately.

     if (!UTIL_ORTHOGONAL) {
        atomStoragePtr_->.transformCartToGen(boundary()); 
     }
     exchangerPtr_->exchange();
     pairPotentialPtr_->buildCellList();
     if (!UTIL_ORTHOGONAL) {
        atomStoragePtr_->.transformGenToCart(boundary()); 
     }
     pairPotentialPtr_->buildPairList();
