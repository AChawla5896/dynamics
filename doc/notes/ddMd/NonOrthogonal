------------------------------------------------------------------------
Util::Boundary

    1) Add methods shiftGen(Vector&) and shiftGen(Vector& , intVector&)
       to shift generalized coordinate vectors.

------------------------------------------------------------------------
DdMd::Domain:

     if (UTIL_ORTHOGONAL) {
        1) Change domainBound to return generalized coordinates.
        2) Change ownerRank(Vector& ) to use generalized coordinates
        3) Change isInDomain(Vector& ) to use generalized coordinates.
     }
     Requires new definition of dL in each.

     4) Update unit tests and test

     5) IF we go to consistent use of generalized coordinates in Domain,
        then remove boundaryPtr_ (Used only in above functions)

------------------------------------------------------------------------
DdMd::AtomStorage

     1) Add methods

     void transformCartToGen(const Boundary& boundary);
     void transformGenToCart(const Boundary& boundary);

     2) Add bool member and accessor to mark state and method 
  
     bool coordinatesAreCartesian() const;
     bool coordinatesAreCartesion_;

     3) #ifdef UTIL_ORTHOGONAL initialize coordinatesAreCartesian_ = false
        #else initialize to true
     Can be changed only by transform and clear methods.

     3) Method to clear storage should set coordinatesAreCartesian_ to its
     initial value. 

------------------------------------------------------------------------
DdMd::Distributor

     #ifdef (UTIL_ORTHOGONAL) -> use generalized coordinates throughout.
     Change addAtom to use generalized coordinates
   
     #ifdef (UTIL_ORTHOGONAL) { 
        1) In addAtom, call shiftGen rather than Shift.
        2) Call domainPtr_->ownerRank unchanged.
     #endif


------------------------------------------------------------------------
DdMd::ConfigIo

     Policies:

     1) Coordinates in file are Cartesian
        Motivation: Allows format more similiar to single processor codes.

     2) Coordinates will be generalized upon exit from readConfigIo.
        Motivation: Allows a CelList to be built immediately after reading.
                    Leaves coordinates in form used internally
                    Delay transformation to Cartesian until needed.

     3) Coordinates will be Cartesian throughout writeConfigIo.
        Motivation: Coordinates will be Cartesian throughout most time steps.
                    Cartesian coordinates are needed in output file.

     Changes, in readConfig:

     1) clear AtomStorage
     2) if (!UTIL_ORTHOGONAL) transform positions to 
     generalized coordinates immediately after reading.

------------------------------------------------------------------------
DdMd::Exchanger:

     if (UTIL_ORTHOGONAL) use generalized coordinates throughout:

     1) Within loop over i to define limiting coordinate values:
        Define local variable  length = boundary.length()[i];
        Define local variable  cut = cutoff_/length
        Define inner_ and outer_ as bound +- cut
    
     2) Wherever particle positions are shifted, if (!UTIL_ORTHOGONAL)
        use generalized coordinate shift:

        double rshift = 1.0*shift
        position = position + rshift 

     3) Update ExchangerTest and retest.

------------------------------------------------------------------------
DdMd::Collector

     Appears to be completely unchanged -> particles are sent to
     master processor without using information about positions.

------------------------------------------------------------------------
CellList:

     if (UTIL_ORTHOGONAL) use generalized coordinates throughout:

     1) Define allocate and makeGrid method that takes a Vector of 
     cutoff lengths. Each should be defined externally as a ratio
     cutoff_/boundary.length()[i].

     2) If we decide on consistent use of generalized coordinates,
     remove boundaryPtr_ (unnecessary).

------------------------------------------------------------------------
PairPotential:

     1) Separate buildCellList and buildPairList methods.

     2) If (UTIL_ORTHOGONAL) use generalized coordinates throughout 
     buildCellList and Cartesian throughout buildPairList.

------------------------------------------------------------------------
Integrators:

     1) Invoke methods to transform atomic coordinate systems.
     2) Call buildCellList and buildPairList separately.

     if (!UTIL_ORTHOGONAL) {
        atomStoragePtr_->.transformCartToGen(boundary()); 
     }
     exchangerPtr_->exchange();
     pairPotentialPtr_->buildCellList();
     if (!UTIL_ORTHOGONAL) {
        atomStoragePtr_->.transformGenToCart(boundary()); 
     }
     pairPotentialPtr_->buildPairList();
     
