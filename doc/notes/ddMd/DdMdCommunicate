
Communication pattern with groups (bonds, angles, ...)

Classes (modified and new):

  Atom:      Add bool send_ member 
             Add int  procId_ member

  AtomTag: Identifier for an atom within a groups
             int id_;            // global atom id
             int procId_;        // id of home processor

  Group<N>: A group represents a group of N covalently bonded atoms.  
            It has:

               FArray<Atom*, N> atomPtrs_;    // pointers to atoms
               FArray<int, N>   atomProcIds_; // home processor ids for atoms
               FArray<in, N>    atomIds_;     // global ids for atoms
               int typeId_;                   // type id for group
               int id_;                       // global id for group
               int nLocal_;                   // # of local atoms.

  GroupStorage<N>: Analogous to Storage (to be renamed AtomStorage).

            Each GroupStorage<N> has:

               A DArray< Group <N> > of all allocated groups.
               An ArraySet< < Group<N> > > of all groups in system
               An ArraySet< < Group<N> > > of incomplete groups

void Exchanger::exchangeAtoms() 
{

   // Precondition: Must be preceded by a final call to communicateGhosts
   // so that ghost positions are up to date.
 
   Loop over local atoms {
      calculate home processor Id, store in Atom::procId_
   }
   Loop over ghost atoms {
      calculate home processor Id, store in Atom::procId_
   }
   Loop over groups {
      for each atom in group {
         update procIds_ in AtomTag
      }
   }

   // At this point procIds are up to date in all groups

   Clear Ghosts

   Loop over Cartesian direction i {
      Loop over sign j = 0, 1{
     
         # Process atoms for sending
         For each local atom {
            set Atom::send_ = false for atom
            if atom must be sent in this direction{
               pack atom
               set send = true for atom
               remove atom from storage
            }
         }

         # Process groups for sending
         For each group {
            sendGroup  = false;
            empty = true;
            For each atom in group {
               if (atom is local) {
                  empty = false;
               }
               if (atom is marked send = true) {
                  sendGroup = true;
                  nullify pointer to atom;
               }
            }
            pack group for sending (send everything but local pointers)
            if (empty) {
               remove group from groupStorage.
            }
         }

         Send and receive buffers

         For each atom in recvbuffer {
            add to atomStorage
         }

         For each group in recvBuffer {
            if not in groupStorage {
               add to groupStorage; 
            }
         }

      } // loop over j
 
   } // loop over i

   // Add all local atoms to all groups
   // Identify all incomplete groups
   For each group {
      nLocal = 0;
      for each atom {
         if atom is local {
            if pointer in Group is null {
               find atom;
               assert(atom is found and is local)
               set atom ptr in Group;
               ++nLocal
            }
         }
      }
      if (nLocal < N) {
         add to incomplete group list
      }
   }

   // At this point:
   // All local atoms are on correct processor.
   // No ghost atoms exist.
   // All pointers to local atoms in Groups are set.
   // All pointers to ghost atoms in Groups are null.
   // All incomplete groups are in incomplete group list

}

void Exchanger::exchangeGhosts 
{

   Loop over Cartesian direction i {
      Loop over sign j = 0, 1 {
   
         // Identify non-bonded ghosts (identified by position)
         For each local atom and each ghost atom {
            if (atom is in the send slab) {
               add to sendList;
               mark the atom;
               pack for sending;
            }
         }

         // Identify covalent ghosts (identified by atom procId)
         For each group {

            // Determine if all atoms in group must be sent as ghosts.
            // Criterion: Does group contain any atom that must be sent,
            //            based on atom home processor ids.
            send = false
            For each atom in group {
               if (should be sent based on procId) {
                  send = true
                  break
               }
            }

            // If group must be sent, pack atoms
            if (send) {
               for each atom in group {
                  if (atom not marked for sending) {
                     add atom to sendList;
                     mark the atom;
                     pack for sending
                  }
               }
            }

         } 

         Send and receive buffers

         For each atom in recvbuffer {
            add to atomRecvList
            add to atomStorage
         }

      }
   } // Ghost exchange communication completed

   // Add ghost atoms to groups
   For each incomplete group {
      for each atom in group {
         if pointer is null {
            assert(atom owned by another processor)
            find ghost atom;
            assert(ghost atom is found);
            set ptr in Group
         }
      }
   }

}

Exchanger::updateGhosts 
{

   // Unchanged, I think.
   // Use send and receive lists to communicate only positions.

}
