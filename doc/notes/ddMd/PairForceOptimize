
/* Proposal to make pair force loop more pipeline friendly */

class PairPotential::Pair {
public:
   Vector dr;      // 24 bytes
   double rsq;     // 32 
   Atom*  ptr1;    // 40 
   Atom*  ptr2;    // 48 
}

Idea: 1) Pipelineable dR and dRSq calculation

Pair*   pairs_;   // array
Pair**  inPairs_; // array of pointers

unsigned int nFinish = 0;
unsigned int nRemain = nPair;
Pair* pairPtr;

while (nRemain) {
 
   n = std::min(iRemain, BLOCK_SIZE);

   // Vectorizable loop
   for (i = 0; i < n; ++i) {
      pairIterator(ptr1, ptr2);
      pairPtr = pairs_[i];
      pairPtr->dr.subtract(ptr1->position(), ptr2->position());
      ++pairIterator();
      pairPtr->Ptr1 = ptr1;
      pairPtr->Ptr2 = ptr2;
      pairPtr>drsq = dr.square();
   }

   // Non-vectorizable loop
   nIn = 0;
   for (i = 0; i < n; ++i) {
      pairPtr = pairs_[i];
      ptr1 = pairPtr->Ptr1;
      ptr2 = pairPtr->Ptr2;
      cutoffSq = pairPotential().cutoffSq(ptr1->typeId(), ptr2->typeId());
      inPairs_[nIn] = pairPtr;
      if (rsq < cutoff) {
         ++nIn;
      }
   }

   // Pipeline friendly loop (pointer lookup, but no branches)
   for (i = 0; i < nIn; ++i) {
      pairPtr = inPairs_[i];
      ptr1 = pairPtr->Ptr1;
      ptr2 = pairPtr->Ptr2;
      fPtr = &pairPtr->f;
      *fPtr = interaction_.forceOverR(rsq, ptr1->typeId(), ptr2->typeId());
      ptr1->force() += *(fPtr);
      ptr2->force() -= *(fPtr);
   }

}
