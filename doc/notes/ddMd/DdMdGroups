Classes:

    Group<int N>
    GroupStorage<int N>

    Atom may have to modifid as well.

Exchange:

    1) Particles are exchanged based on their distance from a boundary.

    2) If a particle migrates, all groups that contain it must migrate as 
       well (though they may already be known at the receiving end).

    3) After deciding to send an atom, the associated groups could be
    identified either:

       i)  By storing a pointer to associated groups with each atom,
           and marking all associated groups when the atom is marked
           for sending. This requires an extra set of data structures
           that point from atoms to groups.

       ii) By marking atoms for sending and then iterating through all
           groups and identifying incomplete groups with atoms that are
           marked for sending. Empty groups should be marked for removal
           from the list, and then removed.

       One way to implement option (i) would allow accumulation of a 
       list of groups that are marked for sending during the loop over 
       atoms, adding each group to the list the first time it is marked
       for sending. 

       The following algorithm could avoid the need to use data 
       structures that point from atoms to groups: After iterating
       over all atoms, and marking some for sending, one could
       iterate over all groups, and search each group for atoms
       that are marked for sending.

    4) When a group is received, its presence on the receiving processor
       must be checked using its global id, and added if not present.

    5) Pointers from groups to local atoms must be established after 
       each group is received.

    6) Some algorithms for exchanging ghosts require the creation of
       a list of incomplete groups. If we identify incomplete groups
       on the sending processor by iterating over  all groups, this 
       could be created afresh at this point. When an incomplete
       group is received, it could then be added to the list. This
       is an argument for identifying incomplete groups by iterating
       through all groups.

Update:

    1) Pair ghosts are sent based on their distance from a boundary.

    2) Covalent ghosts are identified after pair ghosts, and must be 
       sent if:

       - The group is incomplete AND
       - At least one member is within a specified bond length of a
         boundary.

       Algorithm: Maintain a list of incomplete groups. Iterate
       through the list and find all atoms that are within a specified
       distance of the boundary.

     3) To avoid sending an atom twice, atoms must be marked as they
     are identified as ghosts. Atoms thus still require a postmark.

Improvement:

     Exchange of local atoms: Rather than iterating through all local
     atoms 6 times to identify ghosts, we could premark them for sending 
     in each of 6 directions once, and store the data? Atoms could be 
     marked for sending based on either position alone (pair ghosts) 
     or because they belong to a group of covalent ghosts. Local 
     atoms could be added to all relevant send lists before any
     communication occurs, after a single iteration through all 
     atoms.

     Correct resending of pair ghosts requires, however, that they be
     identified after they are received, since the identify of the ghosts
     is not known until they are received. This could be done by:

       - Identif
     Correct resending of pair ghosts requires, however, that we iterate
     over ghosts after each send, as done now. The identity of ghosts
     is not known until they are received.

     Incomplete
     Incomplete groups of covalent ghosts can also be marked for 
     sending in each of 6 directions before any communication.

    

Algorithm #1:
   
    Each atom has a list of atoms to which it is bonded and bond types.
    When a atom migrates, the list migrates with it.
    Ghost positions are based on atom positions alone (reqires a max 
        bond length).
    Space is required per atom for the maximum number of bonds.
    Almost no extra coding required!

    Each atom also has a list of atoms in angles containing it.
    Each angle is listed 3 times.
    Ghostlyness is infectious: If any member of any incomplete group 
       is a ghost,
       you're all ghosts. 
        
    Similar for dihedrals

    Each dihedral is listed 4 times.

    A integer group is n ints, a typeId int, an id int.

    A dihedral is 5 ints x 4 = 20 ints * 4bytes/int = 80 bytes.
    Each atom may have 80 bytes or more of memory.

Alternative 2:

    Each atom stores a pointer to a group: n + 2 ints + n pointer.
    for 8 byte pointers: n(1+2) + 2 ints = 3n + 2
                         n = 2 -> 8
                         n = 3  -> 11
                         n = 4  -> 14
           
         For n = 4, 8 byte pointers, thats 5*8 + 5 = 


