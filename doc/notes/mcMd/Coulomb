---------------------------------------------------------------------
Proposed design:

   Classes:

       // Abstract base class for Fourier space potentials for MD
       class MdKSpacePotential 

       // Base class to hold Ewald rspace parameters 
       class EwaldRSpaceParameters;

       // MD Ewald implementation 
       // Has a private pointer to EwaldRSpaceAccumulators

       class Ewaldotential : public MdKSpacePotential, 
                             public EwaldRSpaceParameters

       // Abstract base class for Md Pair Potentials, with or without
       // short-range Coulombic parts
       class MdPairPotential;

       // Class to hold Ewald rspace energy and stress accumulators
       class EwaldRSpaceAccumulators;

       // Pair Interaction for short range part of Ewald.
       // Holds a pointer to EwaldRSpaceParameters base class.
       class EwaldPair;

       // Implementation for Ewald + nonCoulomb Pair
       // Has a EwaldPair, and a pointer to EwaldRSpaceParameters

       template <class Pair>
       class MdEwaldPairPotentialImpl<Pair> : public MdPairPotential

   Principles:

   1) MdKSpacePotential and PairPotential classes each have a 
   hierarchy with an abstract base class that defines an interface 
   and implementation class or class template that define nuts and 
   bolts of the implementation.

   2) Short-range non-Coulomb and short range part of Coulomb 
   forces are computed in the same loop by template instantiation 
   MdEwaldPairPotentialImpl<Pair>, but are stored in different
   accumulators.

   3) Values for physical and algorithm parameters associated with 
   Coulomb interactions are input in the MdKSpacePotential part of 
   the parameter file, but are shared as needed with the 
   PairPotential class (mechanism described below).

   4) MdKSpacePotential part of the parameter file should appear
   in the parameter file, if at all, as the first potential
   energy block, before the PairPotential block. This allows the
   code that reads the PairPotential block of the parameter file
   to make decisions based on full knowledge of the parameters 
   of the Ewald algorithm, including the rspace cutoff.

   5) EwaldRSpaceParameters has public member functions to access 
   values of the physical and algorithmic parameters required to 
   define the r-space part of the Coulomb potential, namely 
   dielectric constant, alpha, and r-space cutoff. These variables
   are all protected members so that they can be modified by the
   MdEwaldPotential derived class.

   6) MdEwaldRSpaceParmaeters provides public member functions to
   to access rSpace energy and stress accumulators. These accumulators
   are Setable<Type> protected members, so that they can be modified
   by the MdEwaldPairPotentialImpl<Pair> derived class.

   7) The MdEwaldPotential holds a pointer to the EwaldRSpaceAccumulator
   base class of MdEwaldPairPotentialImpl<Pair>, and 
   MdEwaldPairPotentialImpl<Pair> holds a pointer to the 
   EwaldRSpaceParameters base class of MdEwaldPotential.  The required 
   addresses are obtained in each case by using a dynamic cast of a 
   pointer to the base class to the relevant implementation subclass,
   and then casting this to a pointer to the EwaldRSpace.. base class 
   part.

   8) The energy and stress accessors of the MdPairPotential base
   class, which are implemented by the MdEwaldPairPotentialImpl<Pair>
   template, return values of the non-coulombic (e.g., Lennard-Jones)
   part of the potential. A separate set of non-iherited functions of
   MdEwaldPairPotentialImpl<Pair> provide access to the rspace
   part of the coulomb energy and stress. 
   

-------------------------------------------------------------------
    Class sketches:

   /// Abstract base class for potentials with K-space part
   /// Interface class - no data
   MdKSpacePotential : public ParamComposite
   {
   public:

       void setPairPotential(MdPairPotential& pairPotential) = 0;

       // Add K-Space forces
       virtual void addForces() = 0;

       // Compute KSpace energy and stress components
       virtual void computeEnergy() = 0;
       virtual void computeStress() = 0;

       // Unset accumulators for kspace energy and stress components.
       virtual void unsetEnergy();
       virtual void unsetSress();

       // Return total energy and stress
       virtual double energy() const = 0;
       virtual double pressure() const = 0;
       virtual Tensor stress() const = 0;

       // Return K-space contributions
       virtual double kSpaceEnergy() const = 0;
       virtual double kSpacePressure() const = 0;
       virtual Tensor kSpaceStress() const = 0;

       // Return R-space contributions
       virtual double rSpaceEnergy() const = 0;
       virtual double rSpacePressure() const = 0;
       virtual Tensor rSpaceStress() const = 0;

       // Note: Public functions to return rspace components are
       // needed in this base class because the MdPairPotential base 
       // class interface does not provide access to these values, and
       // the user has access to the MdEwaldPairPotentialImpl<Pair>
       // only through a pointer to the MdPairPotential base class.
       // Because they are specific to Coulomb interactions, it makes
       // more sense to provide access here rather than in the
       // interface for MdPairPotential.

   }

   class EwaldRSpaceParameters
   {
   public:

      double alpha() const 
      {  return alpha_; }

      double epsilon() const 
      {  return alpha_; }

      double rCutoff() const 
      {  return rCutoff_; }

   protected:

      // Physical Parameters
      double epsilon_;

      // Algorithmic parameters
      double alpha_;
      double rCutoff_;

   }

   /**
   * Ewald KSpace Coulomb potential implementation class
   */
   MdEwaldPotential : public MdKSpacePotential, 
                    public EwaldRSpaceParameters
   {
   public:

      // Constructor
      MdEwaldPotential(System& system)
      {}

      // Add K-Space forces
      void addForces();

      // Compute KSpace energy and stress components
      void computeEnergy();
      void computeStress();

      // Unset KSpace energy and stress components
      void unsetEnergy();
      void unsetStress();

      // Return total Coulomb energy and stress (kspace + rspace)
      double energy();
      double pressure();
      Tensor stress();

      // Return K-space contributions
      double kspaceEnergy();
      double kSpacePressure();
      Tensor kSpaceStress();

      // Return R-space contributions
      double rSpaceEnergy()
      { return rspaceAccumulatorPtr_->rSpaceEnergy(); }

      double kSpacePressure();

      Tensor kSpaceStress();
      { return rspaceAccumulatorPtr_->rSpaceStress(); }

    private:

      // KSpace part of Coulomb energy
      Setable<double> energy_;

      // KSpace part of Coulomb stress.
      Setable<double> stress_;

      // Pointer to accumulator part of MdEwaldPairPotentialImpl
      EwaldRSpaceAccumulator* rSpaceAccumulatorPtr_;
   }

   /// Ewald Coulomb pair interaction class (analogous to LJPair)
   class EwaldPair : public ParamComposite
   {
   public:

      void setParams(EwaldRSpaceParameters& ewaldParams)
      {  ewaldParamPtr_ = & ewaldParams; }

   private:

      EwaldRSpaceParameters* ewaldParamPtr_;

   }

   /// Base class containing Ewald RSpace accumulators
   class EwaldRSpaceAccumulators
   {

      // Check if energy and stress accumulators are set.

      void isSetEnergy() const
      {  return rSpaceEnergy_.isSet(); }

      void isSetStress() const
      { return rSpaceStress_.isSet(); }

      // Note: Because non-Coulombic and Ewald rSpace accumulators
      // are set and unset together in MdEwaldPairPotentialImpl, 
      // it is only necessary to check the rSpace accumulators
      // to know the state of both accumulators.

      double rSpaceEnergy() const
      { return rSpaceEnergy_.value(); }

      Tensor rSpaceStress() const
      { return rSpaceStress_.value(); }

      Tensor rSpacePressure() const;

   protected:

      Setable<Tensor> stress_;       // non-Coulombic
      Setable<Tensor> pairStress_;   // rspace Coulombic

   }

   /// Ewald +_Pair potential class template
   template <class Pair>
   class MdEwaldPairPotentialImpl<Pair>
    : public MdPairPotential, public EwaldRSpaceAccumulators
   {

      MdEwaldPairPotentialImpl(MdSystem& system)
      {
         // Get pointer to MdKSpacePotential.
         MdKSpacePotential* kspacePtr = 0;
         kspacePtr = &system.kspacePotential();

         // Dynamic cast to a pointer to MdEwaldPotential.
         MdEwaldPotential* ewaldPtr = 0; 
         ewaldPtr = dynamic_cast<MdEwaldPotential*>(kspacePtr);

         // Pass address of MdEwaldPotential to EwaldPair interaction
         ewaldPair.setParams(*ewaldPtr);
      }

      // Force evaluation, which adds both types of pair force.
      virtual void addForces();

      /** 
      * Thermo computes, which computes nonCoulombic and coulombic
      * parts, but stores them in different accumulator variables.
      * The implementation should also mark both accumulators as set.
      */
      virtual void computeEnergy();
      virtual void computeStress();

      // Unset both energy accumulators.
      void unsetEnergy();
      { 
         energy_.unset(); 
         rSpaceEnergy_.unset(); 
      }

      // Unset both stress accumulators.
      void unsetStress();
      { 
         stress_.unset(); 
         rSpaceStress_.unset(); 
      }

      double rSpaceEnergy() const
      { return rSpaceEnergy_.value(); }

      // Get non-coulombic pair stress.
      Tensor stress()
      {  return stress_.value(); }

      // Get non-coulombic pair pressure.
      double pressure();

   private:

      Setable<double> energy_;       // non-Coulombic
      Setable<double> pairEnergy_;   // rspace Coulombic

      // Pointer to associated MdEwaldPotential
      MdEwaldPotential* ewaldPtr_;

      // Non-Coulombic pair interaction
      Pair pair_;

      // Ewald short-range pair Interaction
      EwaldPair ewaldPair_;

   }

