---------------------------------------------------------------------
Proposed design:

   Classes:

       // Abstract base class for Fourier space potentials for MD
       class MdCoulombPotential 

       // Base class to hold Ewald rspace parameters 
       class EwaldParameters;

       // MD Ewald implementation 
       // Has a private pointer to EwaldRSpaceAccumulator

       class EwaldPotential : public MdCoulombPotential, 
                              public EwaldParameters

       // Abstract base class for Md Pair Potentials, with or without
       // short-range Coulombic parts
       class MdPairPotential;

       // Class to hold Ewald rspace energy and stress accumulators
       class EwaldRSpaceAccumulator;

       // Pair Interaction for short range part of Ewald.
       // Holds a pointer to EwaldParameters base class.
       class EwaldPair;

       // Implementation for Ewald + nonCoulomb Pair
       // Has a EwaldPair, and a pointer to EwaldParameters

       template <class Pair>
       class MdEwaldPairPotentialImpl<Pair> : public MdPairPotential

   Principles:

   1) MdCoulombPotential and PairPotential are abstract base classes 
   with functions that are implemented by concrete subclasses
   MdEwaldPotential and MdEwaldPairPotentialImpl<Pair>, respectively.

   2) Short-range non-Coulomb pair potentials and short range part 
   of the Coulomb potential are computed in the same loop by template 
   instantiation MdEwaldPairPotentialImpl<Pair>. Corresponding energy
   and stress components are, however, stored in different
   accumulators.

   3) Values for physical and algorithm parameters associated 
   with Coulomb interactions are input in the CoulombPotential 
   part of the parameter file, but are shared as needed with the 
   MdEwaldPairPotentialImpl<Pair> class (mechanism described below).

   4) MdCoulombPotential part of the parameter file should appear
   first in the parameter file, if at all, before the MdPairPotential 
   block. This allows the code that reads the PairPotential block of 
   the parameter file to make decisions regarding, e.g., the Verlet
   list cutoff, based on full knowledge of the rSpaceCutoff of the 
   Ewald algorithm.

   5) EwaldParameters has public member functions to access values 
   of the physical and algorithmic parameters required to define 
   the r-space and k-space parts of the Coulomb potential, namely 
   dielectric constant, alpha, r-space cutoff and the k-Space cutoff
   or grid. These variables are all protected members so that they 
   can be modified by the MdEwaldPotential derived class.

   6) EwaldRSpaceAccumulator provides public member functions to
   access rSpace energy and stress accumulators. These accumulators
   are Setable<Type> protected members, so that they can be modified
   by the MdEwaldPairPotentialImpl<Pair> derived class.

   7) The EwaldPotential has a pointer to the EwaldRSpaceAccumulator
   base class of MdEwaldPairPotentialImpl<Pair>. Similarly, the
   EwaldPair has a pointer to the EwaldParameters base class of 
   MdEwaldPotential. The required addresses are obtained in each 
   case by using a dynamic cast of a pointer to the base class 
   to the relevant implementation subclass, and then casting this 
   to a pointer to a base class.  (See class skeletons for details).

   8) The energy and stress accessors of the MdPairPotential base
   class, which are implemented by the MdEwaldPairPotentialImpl<Pair>
   template, return values of the non-coulombic (e.g., Lennard-Jones)
   part of the pair potential. A separate set of non-iherited 
   functions of MdEwaldPairPotentialImpl<Pair> provide public 
   access to the rspace part of the coulomb energy and stress. 

-------------------------------------------------------------------
   Class sketches:

   /// Abstract base class for potentials with K-space part
   /// Interface class - no data
   MdCoulombPotential : public ParamComposite
   {
   public:

       void setPairPotential(MdPairPotential& pairPotential) = 0;

       // Add K-Space forces
       virtual void addForces() = 0;

       // Compute KSpace energy and stress components
       virtual void computeEnergy() = 0;
       virtual void computeStress() = 0;

       // Unset accumulators for kspace energy and stress components.
       virtual void unsetEnergy();
       virtual void unsetSress();

       // Return total energy and stress
       virtual double energy() const = 0;
       virtual double pressure() const = 0;
       virtual Tensor stress() const = 0;

       // Return K-space contributions
       virtual double kSpaceEnergy() const = 0;
       virtual double kSpacePressure() const = 0;
       virtual Tensor kSpaceStress() const = 0;

       // Return R-space contributions
       virtual double rSpaceEnergy() const = 0;
       virtual double rSpacePressure() const = 0;
       virtual Tensor rSpaceStress() const = 0;

       // Note: Public functions to return rspace components are
       // needed in this base class because the MdPairPotential base 
       // class interface does not provide access to these values, and
       // the user has access to the MdEwaldPairPotentialImpl<Pair>
       // only through a pointer to the MdPairPotential base class.
       // Because they are specific to Coulomb interactions, it makes
       // more sense to provide access here rather than in the
       // interface for MdPairPotential.

   }

   class EwaldParameters
   {
   public:

      double alpha() const 
      {  return alpha_; }

      double epsilon() const 
      {  return alpha_; }

      double rCutoff() const 
      {  return rCutoff_; }

   protected:

      // Physical Parameters
      double epsilon_;

      // Algorithmic parameters
      double alpha_;
      double rCutoff_;

      // Need some way of specifying k-space cutoff, either
      // as a value or dimensions of a grid.

   }

   /**
   * Ewald KSpace Coulomb potential implementation class
   */
   MdEwaldPotential : public MdCoulombPotential, 
                      public EwaldParameters
   {
   public:

      // Constructor
      MdEwaldPotential(System& system)
      {}

      // Add K-Space forces
      void addForces();

      // Compute KSpace energy and stress components (inherited)
      void computeEnergy();
      void computeStress();

      // Unset KSpace energy and stress components (inherited)
      void unsetEnergy();
      void unsetStress();

      // Return total Coulomb energy and stress (kspace + rspace)
      double energy();
      double pressure();
      Tensor stress();

      // Return K-space contributions (inherited)
      double kspaceEnergy();
      double kSpacePressure();
      Tensor kSpaceStress();

      // Return R-space contributions (inherited)
      double rSpaceEnergy()
      { return rspaceAccumulatorPtr_->rSpaceEnergy(); }

      double kSpacePressure();

      Tensor kSpaceStress();
      { return rspaceAccumulatorPtr_->rSpaceStress(); }

    private:

      // KSpace part of Coulomb energy
      Setable<double> energy_;

      // KSpace part of Coulomb stress.
      Setable<Tensor> stress_;

      // Pointer to accumulator part of MdEwaldPairPotentialImpl
      EwaldRSpaceAccumulator* rSpaceAccumulatorPtr_;
   }

   /// Ewald Coulomb pair interaction class (analogous to LJPair)
   class EwaldPair : public ParamComposite
   {
   public:

      void setParams(EwaldParameters& ewaldParams)
      {  ewaldParamPtr_ = & ewaldParams; }

   private:

      EwaldParameters* ewaldParamPtr_;

   }

   /// Base class containing Ewald RSpace accumulators
   class EwaldRSpaceAccumulator
   {

      // Check if energy and stress accumulators are set.

      void isSetEnergy() const
      {  return rSpaceEnergy_.isSet(); }

      void isSetStress() const
      { return rSpaceStress_.isSet(); }

      // Note: Because non-Coulombic and Ewald rSpace accumulators
      // are set and unset together in MdEwaldPairPotentialImpl, 
      // it is only necessary to check the rSpace accumulators
      // to know the state of both accumulators.

      double rSpaceEnergy() const
      { return rSpaceEnergy_.value(); }

      Tensor rSpaceStress() const
      { return rSpaceStress_.value(); }

      Tensor rSpacePressure() const;

   protected:

      Setable<Tensor> stress_;       // non-Coulombic
      Setable<Tensor> pairStress_;   // rspace Coulombic

   }

   /// Ewald +_Pair potential class template
   template <class Pair>
   class MdEwaldPairPotentialImpl<Pair>
    : public MdPairPotential, public EwaldRSpaceAccumulator
   {

      MdEwaldPairPotentialImpl(MdSystem& system)
      {
         // Get pointer to MdCoulombPotential.
         MdCoulombPotential* kspacePtr = 0;
         kspacePtr = &system.kspacePotential();

         // Dynamic cast to a pointer to MdEwaldPotential.
         MdEwaldPotential* ewaldPtr = 0; 
         ewaldPtr = dynamic_cast<MdEwaldPotential*>(kspacePtr);

         // Pass address of MdEwaldPotential to EwaldPair interaction
         ewaldPair.setParams(*ewaldPtr);
      }

      // Force evaluation, which adds both types of pair force.
      virtual void addForces();

      /** 
      * Thermo computes, which computes nonCoulombic and coulombic
      * parts, but stores them in different accumulator variables.
      * The implementation should also mark both accumulators as set.
      */
      virtual void computeEnergy();
      virtual void computeStress();

      // Unset both energy accumulators.
      void unsetEnergy();
      { 
         energy_.unset(); 
         rSpaceEnergy_.unset(); 
      }

      // Unset both stress accumulators.
      void unsetStress();
      { 
         stress_.unset(); 
         rSpaceStress_.unset(); 
      }

      double rSpaceEnergy() const
      { return rSpaceEnergy_.value(); }

      // Get non-coulombic pair stress.
      Tensor stress()
      {  return stress_.value(); }

      // Get non-coulombic pair pressure.
      double pressure();

   private:

      Setable<double> energy_;       // non-Coulombic
      Setable<double> pairEnergy_;   // rspace Coulombic

      // Pointer to associated MdEwaldPotential
      MdEwaldPotential* ewaldPtr_;

      // Non-Coulombic pair interaction
      Pair pair_;

      // Ewald short-range pair Interaction
      EwaldPair ewaldPair_;

   }

