-------------------------------------------------------------------------------
Existing classes in mcMd/potentials/coulomb:

   CoulombPotential : ParamComposite
   -> Base class for CoulombPotentials (i.e., k-space potentials)
  
   EwaldCoulombPotential : CoulombPotential, CoulombSystemMixIn
   -> Implementation of CoulombPotential
  
   EwaldCoulombPair 
   -> Pair interaction for short range Ewald Coulomb interaction
  
   CoulombPotential has an associated EwaldCoulombPair, which is set by 
   the setPairInteraction() method. CoulombPotential is also a friend of
   EwaldCoulombPair, and so can modify its parameters. 

   MdCoulombPairPotential<PairInteraction, CoulombInteraction>

---------------------------------------------------------------------
Proposed design:

   Principles:

   1) Short-range non-Coulomb and short range part of Coulomb
   forces are computed by the same class, which is a modified
   template implementation of MdPairPotential that is takes
   the Interaction classes that implement the two parts of the
   pair potential as parameters. 

   2) Values for physical and algorithm parameters associated
   with Coulomb interactions are input in the CoulombPotential
   part of the parameter file, but are shared as needed with
   the PairPotential class (mechanism discussed below).

   3) Both CoulombPotential and PairPotential classes have 
   a hierarchy with an abstract base class that defines an
   interface and implementation classes that define nuts and
   bolts of the implementation.

   4) Data is shared between the pair and long-range implementation
   classes by an instance of a specialized class called something
   like EwaldSharedData. One of the two implementation classes is
   derived from EwaldShared data (probably as a private base class), 
   as well as from the class that defines its interface. The other 
   one holds a pointer to the same object, which it should obtain
   either when it is constructed or immediately after. Getting 
   this to work may require a dynamic cast of a pointer to an
   abstract base class to the implementation class, since the
   existence of a EwaldSharedData class is not visible in either 
   abstract base class.

   5) Values of the energy and stress will be accumulated
   separately by the PairPotential implementation for the  
   actual non-coulombic pair interaction and the short range
   part of the Coulomb energy, and this info will we shared with
   the CoulombPotential implementation class through the
   EwaldSharedData class.




   /// Abstract base class for potentials with K-space part
   /// Interface class - no data
   KSpacePotential : public ParamComposite
   {
   public:
       virtual void addForce() = 0;
       virtual void computeEnergy() = 0;
       virtual void computeEnergy() = 0;
       -> public pure virtual accessors kspaceEnergy() and kspaceStress()
       -> public upre virtual accessors rspaceEnergy() and rspaceStress()

   /// Class template for sharing data between pair and kspace potentials
   EwaldSharedData {

       protected:

          // Accumulators for short-range parts of energy and stress
          double rSpaceEnergy_;
          double rSpaceStress_;

          // Algorithmic parameters
          double alpha_;

          // Physical Parameters
          double epsilon_;

   }

   /// Ewald Coulomb pair interaction class (similar to LJPair)
   class EwaldCoulombPairInteraction : public ParamComposite

   /// Pair potential class template
   template <class PairInteraction, CoulombInteraction>
   class MdCoulombPairPotentialImpl<PairInteraction, CoulombInteraction> 
    : public EwaldSharedData
   {

       // Force evaluation, which adds both types of pair force.
       virtual void addForces();

       /** 
       * Thermo computes, which increment different accumulator variables.
       * Conventional nonbonded pair energy and stress are added to member
       * variables of this class.  Ewald RSpace energy and stress are 
       * added corresponding protected data members of the base class
       * RSpacePotentialData<CoulombInteraction>.
       */
       virtual void computeEnergy();
       virtual void computeStress();

       // Accessors for nonbonded non-Ewald coulomb energy and stress.
       double energy();
       double pressure();
       Tensor& stress();
   }

   /**
   * Ewald Coulomb potential concrete class
   */
   EwaldCoulombPotential : public KSpacePotential
   {
   public:

       // Constructor
       EwaldCoulombPotential(MdPairPotential& )
       {
          // cast to RSpacePotentialData<EwaldCoulombPairInteraction>* pointer.
          // Retain address in private pointer variable.
       }

       /// Add K-Space forces
       void addForces();

       /// Compute K-Space forces
       void computeEnergy();
       void computeStress();

       // Return total Coulomb energy and stress
       double energy();
       void stress(double& pressure);
       void stress(tensor& stress);
  
       // Return K-space contributions
       double kspaceEnergy();
       void stress(double& pressure);
       void stress(Tensor& stress);

       // Return R-space contributions
       double rspaceEnergy();
       void rspaceStress(double& pressure);
       void rspaceStress(Tensor& stress);

    private:

       RSpacePotentialData<EwaldCoulombPairInteraction>* rSpaceDataPtr_;

    }
