---------------------------------------------------------------------
Proposed design:

   Classes:

       // Abstract base class for Fourier space potentials for MD
       class MdKSpacePotential 

       // Base class to hold Ewald rspace parameters 
       class EwaldRSpaceParameters;

       // MD Ewald implementation 
       // Note: Has a private pointer to EwaldRSpaceAccumulators
       class EwaldPotential : public MdKSpacePotential, 
                              public EwaldRSpaceParameters

       // Abstract base class for Md Pair Potentials
       // Note: Interface makes no reference to Coulomb potential
       class MdPairPotential;

       // Class to hold Ewald rspace energy and stress accumulators
       class EwaldRSpaceAccumulators;

       // Pair Interaction for short range part of Ewald.
       // Note: Holds a pointer to EwaldRSpaceParameters base class.
       class EwaldPair;

       // Implementation for Ewald + nonCoulomb Pair
       // Note: Has an EwaldPair, and a pointer to EwaldRSpaceParameters
       template <class Pair>
       class MdEwaldPairPotentialImpl<Pair> : public MdPairPotential

   Principles:

   1) MdKSpacePotential and MdPairPotential classes each have a 
   hierarchy with an abstract base class that defines an interface 
   and implementation class or class template that define nuts and 
   bolts of the implementation.

   2) Short-range non-Coulomb and short range part of Coulomb 
   forces are computed in the same loop by template instantiation 
   MdEwaldPairPotentialImpl<Pair>, but are stored in different
   accumulators.

   3) Values for physical and algorithm parameters associated with 
   Coulomb interactions are input in the MdKSpacePotential part of 
   the parameter file, but are shared as needed with the 
   PairPotential class (mechanism described below).

   4) MdKSpacePotential part of the parameter file should appear
   in the parameter file, if at all, as the first potential
   energy block, before the PairPotential block. This allows the
   code that reads the PairPotential block of the parameter file
   to make decisions based on full knowledge of the parameters 
   of the Ewald algorithm, including the rspace cutoff. Specifically,
   it allows it to choose an appropriate Verlet list cutoff.

   5) EwaldRSpaceParameters has public member functions to access 
   values of the physical and algorithmic parameters required to 
   define the r-space part of the Coulomb potential, namely 
   dielectric constant, alpha, and r-space cutoff. These variables
   are all protected members so that they can be modified by the
   MdEwaldPotential derived class, which reads values from the
   parameter file.

   6) MdEwaldRSpaceAccumulators provides public member functions to
   to access rSpace energy and stress accumulators, and to check if
   they are currently set. These accumulators are Setable<Type> 
   protected members, so that they can be modified by the 
   MdEwaldPairPotentialImpl<Pair> derived class.

   7) The MdEwaldPotential holds a pointer to the 
   EwaldRSpaceAccumulator base class of MdEwaldPairPotentialImpl<Pair>, 
   while MdEwaldPairPotentialImpl<Pair> holds a pointer to the 
   EwaldRSpaceParameters base class of MdEwaldPotential.  The required 
   addresses are obtained in each case by using a dynamic cast of a 
   pointer to the base class to the relevant implementation subclass,
   and then casting this to a pointer to a base class. 

   8) The energy and stress accessors of the MdPairPotential base
   class, which are implemented by the MdEwaldPairPotentialImpl<Pair>
   template, return values of the non-coulombic (e.g., Lennard-Jones)
   part of the potential. A separate set of functions of
   MdEwaldPairPotentialImpl<Pair> that are inherited from
   EwaldRSpaceAccumulators provide access to the rspace part of 
   the coulomb energy and stress. 
   

-------------------------------------------------------------------
    Class sketches:

   /// Abstract base class for potentials with K-space part
   /// Interface class - no data
   MdKSpacePotential : public ParamComposite
   {
   public:

       void setPairPotential(MdPairPotential& pairPotential) = 0;

       // Add K-Space forces
       virtual void addForces() = 0;

       // Compute KSpace energy and stress components
       virtual void computeEnergy() = 0;
       virtual void computeStress() = 0;

       // Unset accumulators for kspace energy and stress components.
       virtual void unsetEnergy();
       virtual void unsetSress();

       // Return total energy and stress
       virtual double energy() const = 0;
       virtual double pressure() const = 0;
       virtual Tensor stress() const = 0;

       // Return K-space contributions
       virtual double kSpaceEnergy() const = 0;
       virtual double kSpacePressure() const = 0;
       virtual Tensor kSpaceStress() const = 0;

       // Return R-space contributions
       virtual double rSpaceEnergy() const = 0;
       virtual double rSpacePressure() const = 0;
       virtual Tensor rSpaceStress() const = 0;

       // Note: Public functions are needed to return rspace components 
       // are needed in this base class because the MdPairPotential base 
       // class interface does not provide access to these values, and
       // public interface of the MdSystem provides access to the 
       // MdEwaldPairPotentialImpl<Pair> only through a pointer to the 
       // MdPairPotential base class. It makes sense to provide such
       // accessors in the interface of MdKSpacePotential rather than
       // MdPairPotential because they are specifci to Coulomb
       // interactions, and to division into KSpace and RSpace 
       // components that is characteristic of the Ewald method.

   }

   class EwaldRSpaceParameters
   {
   public:

      double alpha() const 
      {  return alpha_; }

      double epsilon() const 
      {  return alpha_; }

      double rSpaceCutoff() const 
      {  return rSpaceCutoff_; }

   protected:

      // Physical Parameters
      double epsilon_;

      // Algorithmic parameters
      double alpha_;
      double rSpaceCutoff_;

   }

   /**
   * Ewald KSpace Coulomb potential implementation class
   */
   class MdEwaldPotential : public MdKSpacePotential, 
                            public EwaldRSpaceParameters
   {
   public:

      // Constructor
      MdEwaldPotential(System& system)
      {}

      // Add K-Space forces
      void addForces();

      // Compute KSpace energy and stress components
      void computeEnergy();
      void computeStress();

      // Unset KSpace energy and stress components
      void unsetEnergy();
      void unsetStress();

      // Return total Coulomb energy and stress (kspace + rspace)
      double energy();
      double pressure();
      Tensor stress();

      // Return K-space contributions
      double kspaceEnergy();
      double kSpacePressure();
      Tensor kSpaceStress();

      // Return R-space contributions
      double rSpaceEnergy()
      { return rspaceAccumulatorPtr_->rSpaceEnergy(); }

      double kSpacePressure();

      Tensor kSpaceStress();
      { return rspaceAccumulatorPtr_->rSpaceStress(); }

      /*
      * All accessor functions can be designed so that they throw
      * Exceptions upon any attempt to access the value of a 
      * Setable parameter that is not set. The accessors for total
      * energy and stress should throw Exceptions if either kspace
      * or rSpace component is not set. 
      */

    private:

      // KSpace part of Coulomb energy
      Setable<double> energy_;

      // KSpace part of Coulomb stress.
      Setable<double> stress_;

      // Pointer to accumulator part of MdEwaldPairPotentialImpl
      EwaldRSpaceAccumulator* rSpaceAccumulatorPtr_;
   }

   /// Ewald Coulomb pair interaction class (analogous to LJPair)
   class EwaldPair : public ParamComposite
   {
   public:

      void setParams(EwaldRSpaceParameters& ewaldParams)
      {  ewaldParamPtr_ = & ewaldParams; }

   private:

      EwaldRSpaceParameters* ewaldParamPtr_;

   }

   /// Base class containing Ewald RSpace accumulators
   class EwaldRSpaceAccumulators
   {

      // Check if energy and stress accumulators are set.

      void isSetEnergy() const
      {  return rSpaceEnergy_.isSet(); }

      void isSetStress() const
      { return rSpaceStress_.isSet(); }

      // Note: Because non-Coulombic and Ewald rSpace accumulators
      // are set and unset together in MdEwaldPairPotentialImpl, 
      // it is only necessary to check the rSpace accumulators
      // to know the state of both accumulators.

      double rSpaceEnergy() const
      { return rSpaceEnergy_.value(); }

      Tensor rSpaceStress() const
      { return rSpaceStress_.value(); }

      Tensor rSpacePressure() const;

   protected:

      Setable<double> rSpaceEnergy_;  
      Setable<Tensor> rSpaceStress_;  

   }

   /// Ewald +_Pair potential class template
   template <class Pair>
   class MdEwaldPairPotentialImpl<Pair>
    : public MdPairPotential, public EwaldRSpaceAccumulators
   {

      MdEwaldPairPotentialImpl(MdSystem& system)
      {
         // Get pointer to MdKSpacePotential.
         MdKSpacePotential* kspacePtr = 0;
         kspacePtr = &system.kspacePotential();

         // Dynamic cast to a pointer to MdEwaldPotential.
         MdEwaldPotential* ewaldPtr = 0; 
         ewaldPtr = dynamic_cast<MdEwaldPotential*>(kspacePtr);

         // Pass address of MdEwaldPotential to EwaldPair interaction.
         // Note: Uses implicit cast to base class.
         ewaldPair.setParams(*ewaldPtr);
      }

      // Force evaluation, which adds both types of pair force.
      virtual void addForces();

      /** 
      * Thermo computes, which computes nonCoulombic and coulombic
      * parts, but stores them in different accumulator variables.
      * The implementation should also mark both accumulators as set.
      */
      virtual void computeEnergy();
      virtual void computeStress();

      // Unset both energy accumulators.
      void unsetEnergy();
      { 
         energy_.unset(); 
         rSpaceEnergy_.unset(); 
      }

      // Unset both stress accumulators.
      void unsetStress();
      { 
         stress_.unset(); 
         rSpaceStress_.unset(); 
      }

      double rSpaceEnergy() const
      { return rSpaceEnergy_.value(); }

      // Get non-coulombic pair stress.
      Tensor stress()
      {  return stress_.value(); }

      // Get non-coulombic pair pressure.
      double pressure();

   private:

      // Non-Coulombic pair interaction
      Pair pair_;

      // Ewald short-range pair Interaction
      EwaldPair ewaldPair_;

      // Non-Coulomb pair accumulators
      Setable<double> pairEnergy_;  
      Setable<Tensor> pairStress_; 

      // Pointer to associated EwaldRSpaceParameters
      EwaldRSpaceParameters* ewaldParamPtr_;

   }

