namespace McMd
{

/*! \page potentials_page Potential Energy Classes

\section potentials_base_sec Base Classes
Simpatico provides the following set of base classes for different
types of potential energy:
<ul>
 <li> McPairPotential </li>
 <li> MdPairPotential </li>
 <li> BondPotential </li>
 <li> AnglePotential </li>
 <li> DihedralPotential </li>
 <li> ExternalPotential </li>
</ul>
Most of the names are self-explanatory: Bond, Angle, and Dihedral
potentials represent 2-body bond, 3-body angle, and 4-body 
dihedral covalent interactions.  An ExternalPotential represents 
a one-body potential in which the energy depends upon the position 
and type of a single atom. The McPairPotential and MdPairPotential
classes both represent nonbonded pair interactions.

In the special case of nonbonded pair interactions, two different 
base classes, McPairPotential and MdPairPotential, are provided 
for use in MC and MD simulation, respectively. For all other 
potential energy types (i.e., for bond, angle, dihedral, and external 
potentials) a single base class is used in both MC and MD 
simulations.

All of the above potential energy base classes declare methods 
to calculate energies and forces arising from interactions among 
a single groups of atoms, such as a single pair of nonbonded 
atoms.  All of them also provide methods to calculate the 
contribution from a particular type of potential to the total 
energy and total stress or pressure of an associated system. 
All of them except MdPairPotential provide methods to calculate 
the corresponding energy contribution for specific atom, for
use in some MC move algorithms.  All of them except MdPairPotential 
provide a method to calculate the forces exerted on all atoms in 
a System due to the associated type of potential (e.g., all 
nonbonded pair forces, all bond forces, etc.)

\section potentials_evaluator_sec Evaluator Classes and Templates

Subclassses of these potential energy base classes are all
implemented using a simpler set of "evaluator" classes.
Evaluator classes represent specific functional forms for the 
associated potential energy functions, and provide implementations
of the core energy and force calculations for such a function.
For example, LJPair is a pair evaluator class that represents 
the Lennard-Jones pair interaction, and HarmonicBond is a bond
evaluator class that represents a harmonic bond potential.  
The evaluator classes are simple, non-polymorphic classes, 
rather than subclasses of the base clases described above, 
that provide non-virtual methods to calculate the energy 
and forces for a single group of interacting atoms, such 
as a single pair of nonbonded or bonded atoms.  Unlike 
potential energy classes, evaluator classes do not provide 
methods to do calculations that involve, e.g., looping over 
all of the atoms or bonds of an associated system.

Subclasses of the potential energy base classes are 
implemented by a set of class templates that each take 
an Evaluator class as an argument. The names of each
such class templates is given in all but a few cases by 
the name of the associated base class followed by the 
suffix "Impl" (for implementation). For example, the 
template that implements the BondPotential interface
is called BondPotentialImpl. The class
BondPotentialImpl<HarmonicBond> is a subclass of
BondPotential that represents a harmonic bond potential,
in which HarmonicBond is the name of the required evaluator 
class. The template BondPotentialImpl defines methods that 
implement the loop over all bonds in a system, as required 
to calculate the total bond energy of a System and to
calculate bond forces for all atoms in a system. The 
template also provides other methods that simply call the 
methods of the underlying evaluator to obtain the energy 
or force for a single bond. Analogous templates are 
provided for angle, dihedral, link and external forces. 

In the case of non-bonded pair potentials, there are two
different implementation templates, named McPairPotentialImpl 
and MdPairPotentialImpl, for use in MC and MD simulations, 
respectively. These use different algorithms to do the 
energy and force calculations required in MC and MD 
simulations, and implement the different interfaces 
defined by the McPairPotential and MdPairPotential base 
classes.  The McPairPotentialImpl uses a cell list that 
is designed for use in MC simulations, allows efficient
updating of the position of a single atom. The 
MdPairPotentialImpl uses a Verlet pair list that is 
designed to provide an efficient implementation of the
force loop required in MD simulations.

\section potentials_factory_sec Factory Classes 

Simpatico provides a default factory class for each of the 
above types of potential energy. The BondFactory, AngleFactory, 
DihedralFactory, and ExternalFactory are derived from the
Factory template, and use an interface similar to that of
other factory classes.  Like other factory classes, they
all provide a single factory() method that takes a string
argument and that (if possible) returns a pointer to a new 
instance of a subclass of the associated potential energy base 
class.  In all of the potential energy factory classes, the 
name string that is passed as an argument to the factory method 
is actually the name of the required Evaluator classes, rather 
than the name of a subclass of, e.g., BondPotential.  For 
example, if the BondFactory::factory(std::string&) method 
is passed the evaluator class name "HarmonicBond", it 
constructs an instance of BondPotentialImpl<HarmonicBond>, 
and returns a "HarmonicBond* base class pointer to this 
new object.  This is different from the convention used 
for other Factory classes, in which the string argument 
of the factory method is normally taken to be the name 
of a desired subclass of the associated base class.

The PairFactory class actually provides two methods, named 
mdFactory() and mcFactory(), that each take the name of a
pair evaluator, such as "LJPair" for a Lennard-Jones 
interaction, and return a pointer to a new MdPairPotential 
or McPairPotential object that is constructed using the
appropriate implementation template.  The method signatures 
are:
\code
   McPairPotential* mcFactory(std::string className);
   MdPairPotential* mdFactory(std::string className);
\endcode
Because PairFactory does not implement the interface 
defined by the standard Factory template, it is not 
derived from the Factory template. PairFactory also 
provides a third factory method that takes an 
McPairPotential by reference and returns a pointer to
a corresponding MdPairPotential.  This method is used 
in hybrid MC simulations, in which short MD simulations 
are used as proposed MC moves, to construct an 
MdPairPotential of the McPairPotential used by the 
parent MC simulation. 

Except for the differences arisiing from the use of
template to construct subclasses, andd the need to 
write several different factory methods in the case 
of a PairFactory, the implementations of the potential 
energy factory classes are very similar to those of 
other factory classes. Developers should consult the 
implementations of the default factory classes for 
different types of potential the src/potential/ 
directory for further guidance. 

<ul>
 <li> \ref factory_page   (Previous)  </li>
 <li> \ref extend_page    (Up)        </li>
 <li> \ref module_page    (Next)      </li>
</ul>
 
*/
}
