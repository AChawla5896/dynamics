namespace McMd
{

/*! \page factory_page Factory Classes

Simpatico is designed to allow users to use a parameter file to 
choose at run time from among subclasses of each the extensible 
base classes, and thereby choose the particular molecular species, 
file formats, and algorithms required in a particular simulation.
time. Each such subclass of one these base classes is associated 
with a polymorphic block in the parameter file, i.e., a block 
that may specify the name and input parameters for any known 
subclass of the required base class.

The algorithm used by Simpatico to read these blocks in the parameter
file blocks relies on the existence of a Factory class associated with
each of these polymorphic base class.  Each such Factory class provides 
a method that takes the name of a subclass as a string. If this method
can match the string to the name of a known subclass of the associated
base class, it instantiates a new object of the desired subclass, and 
returns a pointer to the new object.  Simpatico provides a default 
implementation of each of these Factory classes, each of which will 
recognize the names of any of the subclasses that are distributed 
with Simpatico. To allow user-defined subclasses to be treated in the
same manner, each new subclass must be added to the set of classes 
that are recognized by the associated factory.

\section factory_structure_sec Factory Class Structure

The Factory class associated with a class named "Base" (where "Base"
could be McMove, MdIntegrator, Diagnostic, etc.) is normally derived 
from the class template Util::Factory < Base >. For example, 
McMoveFactory is derived from the template instantiation 
Util::Factory < McMove >. The Util::Factory template declares a pure 
virtual method named factory() with the following interface.
\code
   template <class Base>
   Base* Factory<Base>::factory(const std::string className) const = 0;
\endcode
This method take the name of a subclass of Base as a string parameter 
className. If the method recognizes this name, it creates a new instance 
of the specified subclass, and returns a Base* pointer to the new 
object.  The pointer to the new object can then be used by the invoking 
function to read the associated parameter file block, by invoking the 
readParam() method of the new object. If the classname string is not 
recognized, the factory method returns a null pointer, and the program 
throws an Exception.

Each Factory can also contain a list of subfactories. Each subfactory
of a Factory<Base> object is another Factory<Base> object.
recognize and instantiate a set of additional subclasses of base.
A Factory and its subfactories form a tree that is searched in a
depth first manner: The factory() method of the default Factory for
a particular base class such as Species or McMove first calls the 
factory() method of each of its subfactories, before attempting
to match the name against its own list of names.  The Factory
template provides a method with the following signature:
\code
   template <class Base>
   void Factory<Base>::addSubfactory(Factory<Base>& subfactory) = 0;
\endcode
which can be used to add a subfactory to a parent factory. Normally,
to add a new class to Simpatico, the use must also provide a custom
factory that can construct an instance of the class, and add this
custom factory as a subfactory of the default Factory for the
associated base classe. 

As an example, consider the MdIntegratorFactory that is distributed
with Simpatico, which is a subclass of Factory<MdIntegrator>. Here 
is the code that defines the MdIntegratorFactory::factory() method:
\code
#include "MdIntegratorFactory.h"

// Subclasses of MdIntegrator 
#include "NVEIntegrator.h"
#include "NVTIntegrator.h"

namespace McMd 
{

   MdIntegrator* MdIntegratorFactory::factory(std::string &className)
   {
      MdIntegrator *ptr = 0;

      // Search subfactories first (if any)
      ptr = trySubfactories(className);
      if (ptr) return ptr;

      // Try matching names of specific subclasses of MdIntegrator.
      if (className == "NveVvIntegrator") {
         // NVE Velocity-Verlet (VV)
         ptr = new NVEIntegrator(*systemPtr_); 
      } else
      if (className == "NvtNhIntegrator") {
         // NVT Nose-Hoover (NH)
         ptr = new NVTIntegrator(*systemPtr_);  
      } else
      if (className == "NVTDpdIntegrator") {
         // NVT Dissipative Particle Dynamics (DPD)
         ptr = new NVTIntegrator(*systemPtr_); 
      }
      return ptr;
   }

}
\endcode
Note that trySubfactories() is called before the method attempts to 
match className to the name of several specific MdIntegrator subclass 
names.  The trySubfactories() method and the factory() method each
returns a null pointer if it cannot find a match for the name, and 
returns a pointer to a new object if it can.

\section custom_factory_extend_sec Writing a Custom Subfactory

To "teach" a factory that is derived from Factory<Base> to recognize 
new user-defined subclasses of Base by name one must either: (1) Edit 
the implementation of the factory that is provided with Simpatico 
(e.g., edit the file MdIntegrator.cpp), or (2) Define a new subclass
of Factory<Base> that recognizes the names of the new subclasses, and 
add this to the default Factory as a subfactory. Though method (1) is 
simpler, we recommend method (2) because it avoids the need to modify 
files that are provided with Simpatico.  We describe method (2) here. 

As an example, imagine that you have written an NvtLangevinIntegrator 
subclass of MdIntegrator, because no Langevin integrator is (thus far)
provided by Simpatico. You would then also define a subclass of 
Factory<MdIntegrator>, which we will called MyMdIntegratorFactory, with 
a factory() method that can recognize the name "NvtLangevinIntegrator"
and instantiate an object of this class.  Here is an example of the 
required class definition:
\code
#include "MdIntegratorFactory.h"
#include "NvtLangevinIntegrator.h"

namespace McMd 
{

   class MyMdIntegratorFactory : public Factory<MdIntegrator>
   {
   public:

      virtual MdIntegrator* factory(std::string &subclassName)
      {
         MdIntegrator *ptr = 0;

         ptr = trySubfactories(className);
         if (ptr) return ptr;

         if (subclassName == "NvtLangevinIntegrator") {
            ptr = new NvtLangevinIntegrator(*systemPtr_);
         }
         return ptr;
      }

   };

}
\endcode
The factory method for this subclass returns a pointer to a new 
NvtLangevinIntegrator, if the string is "NvtLangevinIntegrator",
or returns a null pointer otherwise. 

\section set_factory_extend_sec Registering a Custom Factory 
After writing a Factory, one must invoke the addSubfactory() method 
of the default factory that is provided with Simpatico to register 
the new Factory as a subfactory of the default Factory. This must
be done in the main program, before the readParam() method is
invoked.  

Below, we show an example of a main program for an MdSimulation 
that adds a custom factory MyMdIntegratorFactory as a subfactory
to the MdIntegratorFactory. 
\code
namespace McMd
{

   int main 
   {
      McSimulation          sim;
      MyMdIntegratorFactory myFactory;
 
      \\ Register the custom Factory with the MdSystem
      sim.system().mdIntegratorFactory().addSubfactory(myFactory);

      \\ Read the parameter file from standard input.
      sim.readParam();
  
      \\ Read and execute the command script.
      sim.readCommands();
  
   }

}
\endcode
A similar pattern is used to set user defined Factory classes for
subclasses of Species, McMove, and Diagnostic. The SpeciesFactory
and DiagnosticFactory are accessed through methods of the 
Simulation class. The McMoveFactory is accessible through a method 
of McSimulation.

\section custom_factory_accessor_sec Factory Accessor Methods

Each of the default factory object for each of the polymorphic 
base classes can be accessed by reference via a method of either the 
Simulation or System classes, or of the McSimulation, MdSimulation, 
McSystem or MdSystem subclasses. The required accessor methods for 
factory classes other than the potential energy factories are: 
<ul>
<li> Factory<Species>&       Simulation::speciesFactory(); </li>
<li> Factory<Diagnostic>&    Simulation::diagnosticFactory(); </li>
<li> Factory<McMove>&        McSimulation::mcMoveFactory(); </li>
<li> Factory<MdIntegrator>&  MdSystem::mdIntegratorFactory(); </li>
<li> Factory<ConfigIo>&      System::configIoFactory(); </li>
<li> Factory<TrajectoryIo>&  MdSystem::trajectoryIoFactory(); </li>
<li> Factory<Perturbation>&  System::perturbationFactory(); </li>
</ul>
Access to various potential energy factories is provided by methods
of the System class:
<ul>
  <li> PairFactory&                 System::pairFactory(); </li>
  <li> Factory<BondPotential>&      System::bondFactory(); </li>
  <li> Factory<AnglePotential>&     System::angleFactory(); </li>
  <li> Factory<DihedralPotential>&  System::dihedralFactory(); </li>
  <li> Factory<BondPotential>&      System::linkFactory(); </li>
  <li> Factory<ExternalPotential>&  System::externalFactory(); </li>
</ul>
See the page about \ref potentials_page for a more detailed discussion 
of the potential energy and potential energy factory classes.

When a factory must be accessed via an instance of System or 
one of its subclasesses, a reference to the required McSystem or 
MdSystem object can be obtained using the system() method of the 
parent McSimulation or MdSimulation object. This is done in the 
above example, in which the MdIntegratorFactory is accessed via
the line 
\code
    sim.system().mdIntegratorFactory().addSubfactory(myFactory);
\endcode
Here, sim is an instance of McSimulation. The method 
McSimulation::system() returns a reference to the associated 
McSystem object. The method System::mdIntegratorFactory() then 
returns a reference to the default Factory<MdIntegrator>. 
Invoking the method method Factory<MdIntegrator>::addSubFactory() 
of this factory object then adds the user-defined subfactory to 
the default factory.

<ul>
 <li> \ref inherit_page      (Previous)    </li>
 <li> \ref extend_page       (Up)    </li>
 <li> \ref potentials_page    (Next)    </li>
</ul>
 
*/
}
